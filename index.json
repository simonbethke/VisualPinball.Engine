{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Scripting API | VPE Documentation",
    "keywords": "This section will contain the scripting API documentation."
  },
  "api/VisualPinball.Unity.DeviceSwitch.html": {
    "href": "api/VisualPinball.Unity.DeviceSwitch.html",
    "title": "Class DeviceSwitch | VPE Documentation",
    "keywords": "Class DeviceSwitch Devices switches are switches within a device that are not directly linked to any game item. Inheritance System.Object DeviceSwitch Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public class DeviceSwitch : object, IApiSwitch Constructors | Improve this Doc View Source DeviceSwitch(String, Boolean, SwitchDefault, Player) Declaration public DeviceSwitch(string name, bool isPulseSwitch, SwitchDefault switchDefault, Player player) Parameters Type Name Description System.String name System.Boolean isPulseSwitch VisualPinball.Unity.SwitchDefault switchDefault VisualPinball.Unity.Player player Properties | Improve this Doc View Source Id Declaration public string Id { get; } Property Value Type Description System.String | Improve this Doc View Source IsSwitchClosed Guesses whether the switch is closed or not. Declaration public bool IsSwitchClosed { get; } Property Value Type Description System.Boolean Remarks This is used in the trough inspector to render the switch states. We \"guess\", because in case the switch default is configurable, we don't actually know, because then it depends on each individual mapping. | Improve this Doc View Source IsSwitchEnabled Indicates whether the switch is currently opened or closed. Declaration public bool IsSwitchEnabled { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source AddWireDest(WireDestConfig) Declaration public void AddWireDest(WireDestConfig wireConfig) Parameters Type Name Description VisualPinball.Unity.WireDestConfig wireConfig | Improve this Doc View Source ScheduleSwitch(Boolean, Int32) Schedules the switch to be enabled or disabled. Declaration public void ScheduleSwitch(bool enabled, int delay) Parameters Type Name Description System.Boolean enabled If true, closes mechanical switch or opens opto switch. If false, opens mechanical switch or closes opto switch. System.Int32 delay Delay in milliseconds | Improve this Doc View Source SetSwitch(Boolean) Enables or disables the switch. Declaration public void SetSwitch(bool enabled) Parameters Type Name Description System.Boolean enabled If true, closes mechanical switch or opens opto switch. If false, opens mechanical switch or closes opto switch. Events | Improve this Doc View Source Switch Event emitted when the switch opens or closes. Declaration public event EventHandler<SwitchEventArgs> Switch Event Type Type Description EventHandler < VisualPinball.Unity.SwitchEventArgs >"
  },
  "api/VisualPinball.Unity.FlipperApi.html": {
    "href": "api/VisualPinball.Unity.FlipperApi.html",
    "title": "Class FlipperApi | VPE Documentation",
    "keywords": "Class FlipperApi The scripting API of the flipper. Inheritance System.Object ItemApi < VisualPinball.Unity.FlipperComponent , VisualPinball.Engine.VPT.Flipper.FlipperData > VisualPinball.Unity.CollidableApi < VisualPinball.Unity.FlipperComponent , VisualPinball.Unity.FlipperColliderComponent , VisualPinball.Engine.VPT.Flipper.FlipperData > FlipperApi Inherited Members ItemApi<FlipperComponent, FlipperData>.Name ItemApi<FlipperComponent, FlipperData>.MainComponent ItemApi<FlipperComponent, FlipperData>.OnInit(BallManager) Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public class FlipperApi : CollidableApi<FlipperComponent, FlipperColliderComponent, FlipperData>, IApiColliderGenerator, IApi, IApiHittable, IApiRotatable, IApiCollidable, IApiSwitchDevice, IApiSwitch, IApiCoilDevice, IApiWireDeviceDest Properties | Improve this Doc View Source IsSwitchEnabled Declaration public bool IsSwitchEnabled { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source CreateColliders(List<ICollider>, Single) Declaration protected override void CreateColliders(List<ICollider> colliders, float margin) Parameters Type Name Description List < VisualPinball.Unity.ICollider > colliders System.Single margin Overrides VisualPinball.Unity.CollidableApi<VisualPinball.Unity.FlipperComponent, VisualPinball.Unity.FlipperColliderComponent, VisualPinball.Engine.VPT.Flipper.FlipperData>.CreateColliders(List<VisualPinball.Unity.ICollider>, System.Single) | Improve this Doc View Source RotateToEnd() Enables the flipper's solenoid, making the flipper to start moving to its end position. Declaration public void RotateToEnd() | Improve this Doc View Source RotateToStart() Disables the flipper's solenoid, making the flipper rotate back to its resting position. Declaration public void RotateToStart() Events | Improve this Doc View Source Collide Event emitted when the flipper collided with the ball. Declaration public event EventHandler<CollideEventArgs> Collide Event Type Type Description EventHandler < VisualPinball.Unity.CollideEventArgs > | Improve this Doc View Source Hit Event emitted when the flipper was touched by the ball, but did not collide. Declaration public event EventHandler<HitEventArgs> Hit Event Type Type Description EventHandler < VisualPinball.Unity.HitEventArgs > | Improve this Doc View Source Init Event emitted when the table is started. Declaration public event EventHandler Init Event Type Type Description EventHandler | Improve this Doc View Source LimitBos Event emitted when the flipper comes to rest, i.e. moves back to the resting position. Declaration public event EventHandler<RotationEventArgs> LimitBos Event Type Type Description EventHandler < VisualPinball.Unity.RotationEventArgs > | Improve this Doc View Source LimitEos Event emitted when the flipper reaches its end position. Declaration public event EventHandler<RotationEventArgs> LimitEos Event Type Type Description EventHandler < VisualPinball.Unity.RotationEventArgs > | Improve this Doc View Source Switch Event emitted when the trigger is switched on or off. Declaration public event EventHandler<SwitchEventArgs> Switch Event Type Type Description EventHandler < VisualPinball.Unity.SwitchEventArgs > | Improve this Doc View Source Timer Declaration public event EventHandler Timer Event Type Type Description EventHandler"
  },
  "api/VisualPinball.Unity.html": {
    "href": "api/VisualPinball.Unity.html",
    "title": "Namespace VisualPinball.Unity | VPE Documentation",
    "keywords": "Namespace VisualPinball.Unity Classes DeviceSwitch Devices switches are switches within a device that are not directly linked to any game item. FlipperApi The scripting API of the flipper. ItemApi<TComponent, TData> Base class for all item APIs. TroughApi A trough that implements all known trough behaviors that exist in the real world."
  },
  "api/VisualPinball.Unity.ItemApi-2.html": {
    "href": "api/VisualPinball.Unity.ItemApi-2.html",
    "title": "Class ItemApi<TComponent, TData> | VPE Documentation",
    "keywords": "Class ItemApi<TComponent, TData> Base class for all item APIs. Inheritance System.Object ItemApi<TComponent, TData> TroughApi Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public abstract class ItemApi<TComponent, TData> : object where TComponent : MainComponent<TData> where TData : ItemData Type Parameters Name Description TComponent Component Type TData Item data type Constructors | Improve this Doc View Source ItemApi(GameObject, Player) Declaration protected ItemApi(GameObject go, Player player) Parameters Type Name Description UnityEngine.GameObject go VisualPinball.Unity.Player player Fields | Improve this Doc View Source MainComponent Declaration protected readonly TComponent MainComponent Field Value Type Description TComponent Properties | Improve this Doc View Source Name Item name Declaration public string Name { get; } Property Value Type Description System.String Methods | Improve this Doc View Source OnInit(BallManager) Declaration protected void OnInit(BallManager ballManager) Parameters Type Name Description VisualPinball.Unity.BallManager ballManager"
  },
  "api/VisualPinball.Unity.Patcher.html": {
    "href": "api/VisualPinball.Unity.Patcher.html",
    "title": "Namespace VisualPinball.Unity.Patcher | VPE Documentation",
    "keywords": "Namespace VisualPinball.Unity.Patcher Classes TablePatcher"
  },
  "api/VisualPinball.Unity.Patcher.TablePatcher.html": {
    "href": "api/VisualPinball.Unity.Patcher.TablePatcher.html",
    "title": "Class TablePatcher | VPE Documentation",
    "keywords": "Class TablePatcher Inheritance System.Object TablePatcher Namespace : VisualPinball.Unity.Patcher Assembly : VisualPinball.Unity.Patcher.dll Syntax public abstract class TablePatcher : object Fields | Improve this Doc View Source MaterialProvider Declaration public IMaterialProvider MaterialProvider Field Value Type Description VisualPinball.Unity.IMaterialProvider | Improve this Doc View Source TableContainer Declaration public TableContainer TableContainer Field Value Type Description VisualPinball.Engine.VPT.Table.TableContainer | Improve this Doc View Source TextureProvider Declaration public ITextureProvider TextureProvider Field Value Type Description VisualPinball.Unity.ITextureProvider Methods | Improve this Doc View Source AddLightGroup(GameObject, GameObject, String[]) Adds a light group component to an existing game object. Declaration protected static LightGroupComponent AddLightGroup(GameObject tableGo, GameObject go, params string[] names) Parameters Type Name Description UnityEngine.GameObject tableGo Table game object for retrieving light references. UnityEngine.GameObject go Game object to which the light group is added to. System.String [] names A list of light names that are part of the light group. Returns Type Description VisualPinball.Unity.LightGroupComponent | Improve this Doc View Source ConvertToInsertLight(LightComponent) Converts a normal light to an insert light, by deleting and re-creating the insert prefab. Declaration protected GameObject ConvertToInsertLight(LightComponent lo) Parameters Type Name Description VisualPinball.Unity.LightComponent lo Light component to convert Returns Type Description UnityEngine.GameObject New converted game object | Improve this Doc View Source CreateDropTargetBank(GameObject, GameObject, String, String[]) Creates a drop target bank component. Declaration protected static DropTargetBankComponent CreateDropTargetBank(GameObject tableGo, GameObject go, string name = \"DropTargetBank\", params string[] dropTargetNames) Parameters Type Name Description UnityEngine.GameObject tableGo Table game object, for retrieving references UnityEngine.GameObject go System.String name Name of the new drop target bank System.String [] dropTargetNames Returns Type Description VisualPinball.Unity.DropTargetBankComponent | Improve this Doc View Source CreateEmptyGameObject(GameObject, String) Creates an empty game object. Declaration protected static GameObject CreateEmptyGameObject(GameObject parentGo, string name) Parameters Type Name Description UnityEngine.GameObject parentGo Parent of the new game object System.String name Name of the new game object Returns Type Description UnityEngine.GameObject | Improve this Doc View Source CreateLight(String, Single, Single, GameObject) Creates a point light. Declaration protected static LightComponent CreateLight(string name, float x, float y, GameObject parentGo) Parameters Type Name Description System.String name Name of the new light System.Single x X-position on the playfield System.Single y Y-position on the playfield UnityEngine.GameObject parentGo Game object to parent to (usually \"Lights\") Returns Type Description VisualPinball.Unity.LightComponent | Improve this Doc View Source CreateTrough(GameObject, GameObject, String, String, String) Creates a trough. Declaration protected static TroughComponent CreateTrough(GameObject tableGo, GameObject parentGo, string name = \"Trough\", string exitKicker = \"BallRelease\", string entrySwitch = \"Drain\") Parameters Type Name Description UnityEngine.GameObject tableGo Table game object, for retrieving references UnityEngine.GameObject parentGo Parent game object of the new trough System.String name Name of the new trough System.String exitKicker Name of the exit kicker System.String entrySwitch Name of the entry switch Returns Type Description VisualPinball.Unity.TroughComponent | Improve this Doc View Source DuplicateLight(GameObject, Single, Single, Single) Duplicates a light source. Declaration protected static void DuplicateLight(GameObject go, float x, float y, float z) Parameters Type Name Description UnityEngine.GameObject go Game object of the light source System.Single x X-position of the new light source, relative to the lamp System.Single y Y-position of the new light source, relative to the lamp System.Single z Z-position of the new light source, relative to the lamp | Improve this Doc View Source FindSiblingComponent<T>(MonoBehaviour, String) Declaration protected T FindSiblingComponent<T>(MonoBehaviour mb, string name) where T : MonoBehaviour Parameters Type Name Description UnityEngine.MonoBehaviour mb System.String name Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source GetOrCreateGameObject(GameObject, String) Declaration protected static GameObject GetOrCreateGameObject(GameObject parentGo, string name) Parameters Type Name Description UnityEngine.GameObject parentGo System.String name Returns Type Description UnityEngine.GameObject | Improve this Doc View Source LightColor(GameObject, Color) Sets the light color of a light source. Declaration protected static void LightColor(GameObject go, Color color) Parameters Type Name Description UnityEngine.GameObject go Game object of the light source UnityEngine.Color color New color of the light source Remarks Supports multiple light sources. | Improve this Doc View Source LightIntensity(GameObject, Single) Sets the intensity of a light source in lumen. Declaration protected static void LightIntensity(GameObject go, float intensityLumen) Parameters Type Name Description UnityEngine.GameObject go Game object of the light source System.Single intensityLumen Intensity of the light in lumen Remarks Supports multiple light sources. | Improve this Doc View Source LightPos(GameObject, Single, Single, Single) Sets the light position. Declaration protected static void LightPos(GameObject go, float x, float y, float z) Parameters Type Name Description UnityEngine.GameObject go Game object of the light source System.Single x X-position of the source relative to the light System.Single y Y-position of the source relative to the light System.Single z Z-position of the source relative to the light Remarks Supports multiple light sources. Note that this only applies to the light source, not to the light itself. | Improve this Doc View Source LightRange(GameObject, Single) Sets the range of the light. Declaration protected static void LightRange(GameObject go, float range) Parameters Type Name Description UnityEngine.GameObject go Game object of the light System.Single range Range in meters | Improve this Doc View Source LightShadow(GameObject, Boolean, Boolean, Single) Sets the shadow of the light. Declaration protected static void LightShadow(GameObject go, bool enabled, bool isDynamic, float nearPlane = 0.01F) Parameters Type Name Description UnityEngine.GameObject go Game object of the light System.Boolean enabled Whether to enable or disable shadows. System.Boolean isDynamic If true, update on each frame. System.Single nearPlane Distance from when on shadows are cast. | Improve this Doc View Source LightTemperature(GameObject, Single) Sets the temperature of the light. Declaration protected static void LightTemperature(GameObject go, float temp) Parameters Type Name Description UnityEngine.GameObject go Game object of the light System.Single temp Temperature in Kelvin | Improve this Doc View Source LinkCoil(TableComponent, String, String, ICoilDeviceComponent, String) Links a coil device to an existing coil mapping if it matches a given name. Declaration protected static void LinkCoil(TableComponent tableComponent, string elementName, string coilId, ICoilDeviceComponent coilDevice, string deviceItem = null) Parameters Type Name Description VisualPinball.Unity.TableComponent tableComponent Table component for retrieving mappings. System.String elementName The name that the coil device's GameObject has to match in order to be linked. System.String coilId The ID of the coil mapping that the coil device will be linked to VisualPinball.Unity.ICoilDeviceComponent coilDevice The coil device to be linked System.String deviceItem If set, it's the device item, otherwise the first item of the device. | Improve this Doc View Source LinkCoil(TableComponent, String, ICoilDeviceComponent, String) Links a coil device to an existing coil mapping. Declaration protected static void LinkCoil(TableComponent tableComponent, string coilId, ICoilDeviceComponent coilDevice, string deviceItem = null) Parameters Type Name Description VisualPinball.Unity.TableComponent tableComponent Table component for retrieving mappings. System.String coilId The ID of the coil mapping that the coil device will be linked to VisualPinball.Unity.ICoilDeviceComponent coilDevice The coil device to be linked System.String deviceItem If set, it's the device item, otherwise the first item of the device. | Improve this Doc View Source LinkLights(GameObject, String[]) Creates a light group with the given light names Declaration protected static void LinkLights(GameObject go, params string[] lightNames) Parameters Type Name Description UnityEngine.GameObject go GameObject to add the light group to. System.String [] lightNames Names of the light GameObjects. They must be sister objects of the first parameter. | Improve this Doc View Source LinkSwitch(TableComponent, String, String, ISwitchDeviceComponent) Links a switch device to an existing switch mapping if it matches a given name. Declaration protected static void LinkSwitch(TableComponent tableComponent, string elementName, string switchId, ISwitchDeviceComponent switchDevice) Parameters Type Name Description VisualPinball.Unity.TableComponent tableComponent Table component for retrieving mappings. System.String elementName The name that the switch device's GameObject has to match in order to be linked. System.String switchId The ID of the switch mapping that the switch device will be linked to VisualPinball.Unity.ISwitchDeviceComponent switchDevice The switch device to be linked | Improve this Doc View Source LinkSwitch(TableComponent, String, ISwitchDeviceComponent, String) Links a switch device to an existing switch mapping. Declaration protected static void LinkSwitch(TableComponent tableComponent, string switchId, ISwitchDeviceComponent switchDevice, string switchDeviceItem = null) Parameters Type Name Description VisualPinball.Unity.TableComponent tableComponent Table component for retrieving mappings. System.String switchId The ID of the switch mapping that the switch device will be linked to VisualPinball.Unity.ISwitchDeviceComponent switchDevice The switch device to be linked System.String switchDeviceItem Switch ID inside of the device item. If null, the first switch will be used. | Improve this Doc View Source Playfield(GameObject) Returns the playfield of a given table game object. Declaration protected static GameObject Playfield(GameObject tableGo) Parameters Type Name Description UnityEngine.GameObject tableGo Table game object Returns Type Description UnityEngine.GameObject | Improve this Doc View Source PointRange(GameObject, Single, Single) Sets the angle of a spot light. Declaration protected static void PointRange(GameObject go, float outer, float inner) Parameters Type Name Description UnityEngine.GameObject go Game object of the spot light System.Single outer Outer angle of the spot System.Single inner Inner angle of the spot, in percent of the outer angle Remarks Supports multiple light sources. | Improve this Doc View Source PostPatch(GameObject) This method is executed once after all element-specific patches had been applied. Override this method when you need to create new objects or make global changes to the project. Declaration public virtual void PostPatch(GameObject tableGo) Parameters Type Name Description UnityEngine.GameObject tableGo GameObject of the table. | Improve this Doc View Source PyramidAngle(GameObject, Single, Single) Sets a light source to pyramid spotlight and sets its parameters. Declaration protected static void PyramidAngle(GameObject go, float angle, float ar) Parameters Type Name Description UnityEngine.GameObject go Game object of the light source System.Single angle Angle of the pyramid System.Single ar Aspect ratio of the pyramid Remarks Supports multiple light sources. | Improve this Doc View Source Reparent(GameObject, GameObject) Set a new parent for the given child while keeping the position and rotation. Declaration protected static void Reparent(GameObject child, GameObject parent) Parameters Type Name Description UnityEngine.GameObject child UnityEngine.GameObject parent | Improve this Doc View Source SpotAngle(GameObject, Single, Single) Sets the angle of a spot light. Declaration protected static void SpotAngle(GameObject go, float outer, float inner) Parameters Type Name Description UnityEngine.GameObject go Game object of the spot light System.Single outer Outer angle of the spot System.Single inner Inner angle of the spot, in percent of the outer angle Remarks Supports multiple light sources."
  },
  "api/VisualPinball.Unity.TroughApi.html": {
    "href": "api/VisualPinball.Unity.TroughApi.html",
    "title": "Class TroughApi | VPE Documentation",
    "keywords": "Class TroughApi A trough that implements all known trough behaviors that exist in the real world. Inheritance System.Object ItemApi < VisualPinball.Unity.TroughComponent , VisualPinball.Engine.VPT.Trough.TroughData > TroughApi Inherited Members ItemApi<TroughComponent, TroughData>.Name ItemApi<TroughComponent, TroughData>.MainComponent ItemApi<TroughComponent, TroughData>.OnInit(BallManager) Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public class TroughApi : ItemApi<TroughComponent, TroughData>, IApi, IApiSwitchDevice, IApiCoilDevice, IApiWireDeviceDest Remarks A trough consists of two parts: The drain (often also called \"out hole\" where the ball lands after it exists the playfield. In modern troughs this part does not exist, since the balls go directly into the trough. The ball stack , where balls are stored for games that hold more than one ball. Fields | Improve this Doc View Source EntryCoil The virtual coil that shoots the ball from the drain into the trough. Declaration public DeviceCoil EntryCoil Field Value Type Description VisualPinball.Unity.DeviceCoil Remarks Is null for VisualPinball.Engine.VPT.TroughType.ModernOpto and VisualPinball.Engine.VPT.TroughType.ModernMech | Improve this Doc View Source ExitCoil The virtual coil that ejects the ball. Declaration public DeviceCoil ExitCoil Field Value Type Description VisualPinball.Unity.DeviceCoil | Improve this Doc View Source JamSwitch The virtual switch that sits right above ball 1 and shortly enables and disables after eject. Declaration public DeviceSwitch JamSwitch Field Value Type Description DeviceSwitch Properties | Improve this Doc View Source EntrySwitch The virtual switch that is enabled when the ball lands in the drain. Declaration public DeviceSwitch EntrySwitch { get; } Property Value Type Description DeviceSwitch Remarks Is null for VisualPinball.Engine.VPT.TroughType.ModernOpto , all of modern's switches are in StackSwitch(Int32) . | Improve this Doc View Source NumStackSwitches How many stack switches there are available. Declaration public int NumStackSwitches { get; } Property Value Type Description System.Int32 Remarks The drain switch is not considered a stack switch. | Improve this Doc View Source UncountedDrainBalls The number of balls waiting to be drained because the drain slot is occupied. Once the drain slot is freed, i.e. the ball is kicked over into the ball stack, the next undrained ball enters the drain and this number is decremented by one. Declaration public int UncountedDrainBalls { get; } Property Value Type Description System.Int32 Remarks Usually, the gamelogic engine immediately frees the drain slot and this value should always be zero. | Improve this Doc View Source UncountedStackBalls The stack of a trough can hold an unlimited number of balls. This counts the number of balls in the stack additionally to those counted by the stack's switches. Declaration public int UncountedStackBalls { get; } Property Value Type Description System.Int32 Remarks Usually, games only have as many balls as stack switches and this value should always be zero. Methods | Improve this Doc View Source EjectBall() If there are any balls in the ball stack, eject one to the playfield. Declaration public bool EjectBall() Returns Type Description System.Boolean True if a ball was ejected, false if there were no balls in the stack to eject. Remarks This triggers any switches which the remaining balls would activate by rolling to the next position. | Improve this Doc View Source StackSwitch() Returns the switch for VisualPinball.Engine.VPT.TroughType.TwoCoilsOneSwitch multi ball troughs that only have one switch. Declaration public DeviceSwitch StackSwitch() Returns Type Description DeviceSwitch The stack switch | Improve this Doc View Source StackSwitch(Int32) Returns the stack switch at a given position for VisualPinball.Engine.VPT.TroughType.ModernOpto , VisualPinball.Engine.VPT.TroughType.ModernMech and VisualPinball.Engine.VPT.TroughType.TwoCoilsNSwitches troughs. Declaration public DeviceSwitch StackSwitch(int pos) Parameters Type Name Description System.Int32 pos Position, where 0 is the switch of the ball being ejected next. Returns Type Description DeviceSwitch Switch in the ball stack Events | Improve this Doc View Source Init Event emitted when the table is started. Declaration public event EventHandler Init Event Type Type Description EventHandler"
  },
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | VPE Documentation",
    "keywords": "Changelog This documents all notable changes to the Visual Pinball Engine and its dependent projects. Unreleased Built with Unity 2021.2. Added Trigger meshes can now be easily scaled ( #374 ) We got a new game item called Metal Wire Guide (thanks @Cupiii, #366 ) A Collision Switch component ( #344 , Documentation ). A Rotator component ( #337 , Documentation ). A Teleporter component ( #336 , Documentation ). A Drop Target Bank component ( #333 , Documentation ). Editor: Enable manual trigger for coils, switches, lamps and wires during gameplay ( #332 ) Support for dynamic wires, also known as Fast Flip ( #330 , Documentation ). Component for light groups, allowing easy grouping of GI lamps. ( #330 Documentation ). Slingshot component ( #329 , Documentation ). Create insert meshes ( #320 ). Full support for custom playfield meshes. Remove Hybrid Renderer ( #316 ). Create and use Unity assets when importing ( #320 ). Native support for nFozzy flipper physics ( #305 ). Automated camera clipping ( #304 ). DMD and segment display support ( Documentation ). Plugin: Mission Pinball Framework ( Documentation ). Gamelogic Engine: Support for hardware rules ( #293 ). Support for Extended ASCII strings ( #291 ). Support for Elasticity Falloff in walls (added in VP 10.7) ( #291 ). Support for table notes (added in VP 10.7) ( #291 ). Slow motion during gameplay ( #288 ). Lamp Manager ( #282 ). The VPE core is now also available on NuGet . VPE is now packaged and published on every merge! Native trough component ( #229 , #248 , #256 , Documentation ). Changed Playfield is now rotated to the correct angle during gameplay ( #370 ) Decouple light components from transformation override ( #350 ). Refactored drag points. They are nicely separated and typed now. Collider debug view is now much faster and intuitive. It's also activated per default when there is no visible mesh. Drop and hit targets are now different components. Kicker is now a coil device with different coils for different angles/forces. Ground truth of data is now the scene, not the imported data anymore ( #302 ). Plunger is now a coil device, meaning it can both be pulled back and fired through different inputs. Move render pipelines into separate repos ( #259 ). Put game-, mesh-, collision- animation data into separate components ( #227 , Documentation ). Fixed Ball stuttering when rolling over dropped target ( #375 ). Plunger disappearing due to too small bounding box. Fixed switch status when multiple mappings point to the same ID ( #347 ). Lighting setup. It's now usable ( #330 ). Ball passing through collider plane and disappearing. Alpha channel of color values is now correctly written ( #291 ). Layer names are correctly computed when importing a 10.6 file ( #291 ). Clear texture and material references that don't exist before writing (VP 10.7 behavior) ( #291 ). Bug in writing animation vertices which caused VP to hang when re-reading the file ( #291 ). A few bugs in drag point gizmos ( #246 )."
  },
  "creators-guide/editor/advanced/camera-settings.html": {
    "href": "creators-guide/editor/advanced/camera-settings.html",
    "title": "Camera Settings | VPE Documentation",
    "keywords": "Camera Settings The editor camera controller is a tool designed to set different camera views during the editing and testing process. It allows the camera to be easily adjusted with a few sliders as well as allowing for the saving and loading of presets. The camera controller is setup to orbit around a focal point. While doing this it will automatically adjust the clipping planes on the camera to ensure the best quality shadows and highest precision sorting of transparent objects. Note In most 3D engines, a depth buffer us used for many rendering features such as shadows, transparency sorting and various post process effects. This buffer is a greyscale representation of the distance of a pixel from the camera. As such, it has a limited value range that must be spread to cover the entire scene. The larger the range, the less precision the buffer will have. By closely cropping the range, the precision can be increased. In using the camera controller this is handled automatically. If you add your own camera you will have to adjust this manually. Usage To use the camera controller, select the Camera scene object, which is at the very top of the hierarchy. In the inspector you will find a few sliders: Angle : Controls the angle of the camera to the table. A value of zero places the camera parallel to the table. A value of 90 places the camera perpendicular to the table. Offset XYZ : Moves the pivot point of the camera along the three world axis. X moves the camera left and right relative to where a player would stand. V moves it up and down and Z moves it forward and back. Angle , Distance and Orbit are always relative to this point. Distance : Moves the camera closer to or further away from the pivot point. This is used in conjunction with the FOV to frame the table in view. FOV : Sets the field of view of the camera. High values result in a wide field of view and more depth perspective. Low values narrow and flatten the view. Note Adjusting the distance and FOV together will control how much apparent depth there is to the table. A wide field of view and low distance will give the table a bit of perspective and depth, but will be more challenging to fit in the view without clipping the front, or having a lot of space to the sides in the back. Conversely, moving the camera further away and lowering the FOV will remove much of the perspective allowing the table to fit more evenly in the frame. Orbit : Controls the camera angle in an orbit around the table. 0 and 360 are standing in front of the table, 90 is on the left, 270 to the right. Presets Camera presets are stored camera settings that allow you to rapidly switch between different camera views. This can be useful when developing a table to view specific areas or just to take pretty screenshots. The preset slider changes between the stored camera views. There are three views included by default. Any preset can be overwritten by changing the parameters and clicking the Save button. If Save is not pressed, the values will be lost when you cycle to a new preset. New presets can be made by adjusting the values and clicking Clone . This preset will be added to the presets at the end. You can delete any preset by setting the slider to that preset and clicking the Delete button."
  },
  "creators-guide/editor/coil-manager.html": {
    "href": "creators-guide/editor/coil-manager.html",
    "title": "Coil Manager | VPE Documentation",
    "keywords": "Coil Manager On a real pinball table most moving parts, including the flippers, are triggered by coils (also called solenoids ). In VPE it's the job of the gamelogic engine to trigger them when needed. Just as the coils are physically wired to the power driver board on a regular machine they can be virtually connected in VPE using the coil manager under Visual Pinball -> Coil Manager . Setup Every row in the coil manager corresponds to a logical wire going from a gamelogic engine output to the coil. As with switches, a single coil can be linked to multiple outputs, and an output can be linked to multiple coils. IDs The first column, ID shows the name that the gamelogic engine exports for each coil. Note As we cannot be 100% sure that the gamelogic engine has accurate data about the coil names, you can also add coil IDs manually, but that should be the exception. Description The Description column is optional. If you're setting up a re-creation, you would typically use this for the coil name from the game manual. It's purely for your own benefit, and you can keep this empty if you want. Destination The Destination column defines where the element in the following column is located. There are three options: Playfield lets you select a game element on the playfield that features the coil Device lets you choose a coil device , a mechanism which may include multiple coils, such as a trough . Lamp sets the coil to be configured in the lamp manager (see flashers in the lamp manager for more details). Element The Element column is where you choose which specifc element in the destination column should be activated. VPE can receive coil events for bumpers, flippers, kickers and plungers and coil devices. Note Bumpers are currently hard-wired, i.e. their switch will directly trigger the coil without going through the gamelogic engine. That means they don't need to be configured in the switch or coil manager. VPE will make this configurable in the future. Runtime During runtime, you'll see the coil statuses update in real-time. Clicking on the icon manually toggles the coil, which can be handy for debugging."
  },
  "creators-guide/editor/lamp-manager.html": {
    "href": "creators-guide/editor/lamp-manager.html",
    "title": "Lamp Manager | VPE Documentation",
    "keywords": "Lamp Manager VPE uses the Unity game engine to accurately simulate the many types of lamps a real pinball machine might use, and connect them to the gamelogic engine. Lamps have a standard set of parameters, which can be tweaked in the editor. Lamps in a game are dynamic, so the gamelogic engine can toggle them, fade them, and even change their color. To link each of the playfield lamps to the gamelogic engine and configure how they behave during gameplay, the Lamp Manager is used. You can find it under Visual Pinball -> Lamp Manager . Note We use the terms lights and lamps as follows: With light we're referring to one of the Unity rendering engine's lights . It's a simulated light source which doesn't have to be a physical element on the table, but can also refer to the sun, some directional scene light, or other types of lighting used in the rendering. With lamp we're referring to a virtual \"bulb\" that is present on the table. It's a logical component VPE uses during gameplay, decoupled from the actual visual display. About Lamps Physical machines have many different implementations when it comes to lighting. The vast majority of solid state machines from the 1970s until the early 2010s used a lamp matrix , where lamps were addressed by row/column, and each individual lamp could only be fully on or off. Historically, incandescent light bulbs were used, which resulted in a brief warm-up period until they reached full brightness (and a cool-down period when turned off). To simulate this, VPE adopted the fade-in and fade-out properties for lights from Visual Pinball. Later machines used single colored LEDs that were each directly connected to a controller board (see also: Lights vs LEDs ). Unlike matrix lamps, the intensity of LEDs could be finely controlled by the game software. More recently, games started using RGB-LEDs that can change color as well as brightness during gameplay. In VPE, these can be handled in two different ways: As three single connections from the gamelogic engine, one for each color channel (this is what PinMAME provides, for example.) With a single RGB connection, where the gamelogic engine always provides the full color (used by MPF, or custom table logic.) Additionally, most pinball machines come with GI strands , which are a set of bulbs used for global illumination of the playfield. All lights in a strand are addressed at once, so one gamelogic GI strand maps to multiple lamps on the playfield. Finally, some high-powered lamps such as flashers may appear under the gamelogic engine's coil outputs , since those lamps operate on higher voltage and have the same properties as coils. Setup Every row in the lamp manager corresponds to a logical connection between the gamelogic engine and a lamp on the playfield. A lamp may be linked to multiple outputs, and an output can be linked to multiple lamps. IDs The first column, ID shows the name that the gamelogic engine exports for each lamp. Note Since we cannot be 100% sure that the gamelogic engine has accurate data about the lamp names, you can also add lamp IDs manually, but that should be the exception. Description The Description column is optional. If you're setting up a recreation, you would typically use this for the lamp name from the manual. It's purely for your own benefit, and you can leave this empty if you want. Source GI lights can be emitted as a different type of light from the gamelogic engine. Set the source here in order to prevent conflicts of matching IDs between normal lights and GI lights. Type The Type column defines how the signal is interpreted by the lamp. This is important, because the gamelogic engine typically sends integer values to the lamp. There are four types: Single On|Off - Typically lamps from the lamp matrix. They can only be on or off. Receiving 0 will turn the lamp off, any other value will turn it on. Single Fading - Individual lamps which can be dimmed by the gamelogic engine. Received values can range from 0 to 255 , where 0 turns the lamp off, and 255 sets it to full intensity. RGB Multi - An RGB lamp that can change its color during gameplay. Lamps of this type receive three connections, one from each red, green and blue. Each color channel receives values as a fading lamp. RGB - An RGB lamp that receives its data from a single connection. This is the only mode where the lamp doesn't receive an integer, but an entire color value. Element Under the Element column, you choose which lamp among the game items on the playfield should be controlled. Channel If the type of the previous column has been set to RGB Multi , here is where you define which color channel this output corresponds to. Max. Intensity For fading lights, VPE expects values between 0 and 255 . However, GI light have usually less variations, typically eight. This column is only enabled for GI lights, and the value is the highest value for a given GI strand that the gamelogic engine will emit. Flashers When using a gamelogic engine that simulates real hardware such as PinMAME, high-powered lamps like flashers usually show up as coils connected to the driver board. To support this VPE allows routing coil outputs to lamps. For that, go to the Coil Manager and select Lamp as Destination : This will make the coil show up in the lamp manager where you can configure it: Note that you cannot change the ID of the lamp, because it's still linked to the coil. Also, removing or changing the coil destination will remove the entry from the lamp manager. Changing the ID in the coil manager will also update it in the lamp manager. GI Strands In Visual Pinball, you can put GI lamps into a collection and address the whole collection at once via script. VPE provides light groups as a similar feature. Editor vs Runtime While editing the table in the Unity editor, you may find it helpful to disable lamps you're not editing. You can quickly do that with the top-right controls, which allow you to toggle selectively GIs, inserts, flashers, lamps selected in the manager, or all lamps. You can also quickly select the light source to quickly edit multiple lights. During runtime, VPE first turns all lamps off, then turns on the constant lamps, and then transfers control of the lamps to the gamelogic engine. If you are running the game in the editor, the lamp manager shows the lamp statuses in real time: During gameplay you can also click on the lamp icon to toggle the lamp. This can be handy for debugging."
  },
  "creators-guide/editor/materials.html": {
    "href": "creators-guide/editor/materials.html",
    "title": "Materials | VPE Documentation",
    "keywords": "Materials Materials are what you apply to an object in order to make it look or behave like something in the real world. Materials are one of the key components of a table, because they define the visuals and the physical behavior. However, the term material can be confusing, because it can have different meanings. So let's define them first. Rendered Materials We refer to rendered materials just as materials . They describe how a surface of a mesh is drawn on the sceen. In Unity, materials and shaders are closely linked - every material uses a shader, which you can configure. The most common shader is the Lit shader , which works well for rigid materials that interact with light. A material typically includes one or more textures that define the color, normals, roughness, metalness and many more parameters on a per-pixel basis. Note In Visual Pinball, materials don't include the texture. Instead, the texture is applied on a per-object basis. Physics Materials We refer to how the material interacts with the ball during the physics simulation as the physics material . It has these properties: Elasticity - The bounciness, how much the ball is thrown back when it collides. Elasticity Falloff - Pinball tables have a lot of rubber parts, and rubber has a special attribute: it gets less bouncy when hit at higher velocity. The falloff parameter controls how much. Friction - How much friction is applied when the ball rolls along this material. Scatter - Adds a random factor to the collision angle. Physics materials are a way to group common behavior among certain objects, but contrarily to rendered materials, you can also not assign a physics material to an object and set each of those four parameters individually. Note In Visual Pinball, the physical parameters are part of the rendered material, so there is only one notion of material. Conversion from Visual Pinball As mentioned above, there are two differences between Visual Pinball and VPE how materials are handled: VPE includes textures in the material, while Visual Pinball does not. VPE differentiates between rendered and the physical material. When importing a .vpx file, VPE converts the \"visual part\" of Visual Pinball materials into materials for the current render pipeline. It does that by creating a new material for every material/texture combination in Visual Pinball. The materials are then written to the Materials asset folder of the imported table where they can be easily edited and referenced. Since Visual Pinball uses different shaders than Unity, the results of the conversion are approximations and should be heavily tweaked. Since VPE uses the same physics engine as Visual Pinball, the physical values of the materials don't need to be converted, they are copied 1:1 into a new physics material and saved in the asset folder."
  },
  "creators-guide/editor/multiple-tables.html": {
    "href": "creators-guide/editor/multiple-tables.html",
    "title": "Working with Multiple Tables | VPE Documentation",
    "keywords": "Working with Multiple Tables When working on a creation, you might want to load other tables to pick assets from. For that, Visual Pinball lets you open multiple tables allowing to switch and copy elements between them relatively quickly. With VPE, you can create or import multiple tables into your scene. VPE's manager panels will switch context when an element from a different table is selected in either the Scene view or the Hierarchy. Tip You can lock a manager window to the selected table by clicking on the small lock in the top right corner: Warning We don't have multi-table support during runtime yet. The idea is that in the future, you would be able to select which table is the runtime table. Warning Moving elements between multiple tables is not implemented yet, there is an open issue ."
  },
  "creators-guide/editor/switch-manager.html": {
    "href": "creators-guide/editor/switch-manager.html",
    "title": "Switch Manager | VPE Documentation",
    "keywords": "Switch Manager During gameplay, the gamelogic engine needs to know what is happening on the playfield. For that, real pinball tables have switches on the playfield that signal when a ball rolls over or settles in a certain position. These switches are also built into targets, bumpers, kickers, and other mechanisms (see Supported Game Mechanisms below). Wiring these switches up to the gamelogic engine with code can be a tedious process, so VPE provides a graphical interface where you can do it easily. If you've named them appropriately it can even guess which switch maps to which game item. You can open the switch manager under Visual Pinball -> Switch Manager . Switch matrix from Medieval Madness . Setup Imagine every row as a wire connecting the physical switch to the gamelogic engine. The relation between the two is 0..n -> 0..n , meaning you can link multiple switches to one input or a single switch to multiple inputs. IDs The first column ID shows the names of each switch that the gamelogic engine is aware of. There are two values to fill out here: The first, the dropdown value, is the ID that VPE will use to identify the switch. The second, an integer value, is the ID the gamelogic engine is using. This allows the gamelogic engine to make certain switches more explicit. For example, PinMAME has the same switch mapping all ROMs of a given game. These switches have a readable ID, which then translates into the numeric \"magic value\" that PinMAME uses internally. Global PinMAME switches of WPC games. Note As we cannot be 100% sure that the gamelogic engine has accurate data about the switch names, you can also add switch IDs yourself, but those should be the exception. NC The \"NC\" stands for Normally Closed . In short, enabling this inverts the value sent to the gamelogic engine. As for the long explanation, think about how switches work. Mechanical switches are usually normally open (NO) , meaning they are open by default and close when the ball rolls over them (or, if it's a button, when the button is pressed). But some switches behave differently. In opto-switches for instance, the light beam closes the circuit by default, and a ball rolling through it (and thus blocking the light) opens the switch. These type of switches are normally closed (NC) . Note In the very first screenshot, you'll notice that the trough switches are normally closed. This is because MM uses a modern trough with opto-switches. There is also the coin door we'd like to have closed by default and open the switch when the coin door is open. Description The Description column is optional. If you're setting up a re-creation, you would typically use this for the switch name from the game manual. It's purely for your own benefit, and you can keep this empty if you want. Source The Source column defines where the element in the following column originates. There are four options: Playfield lets you choose a game item from the playfield Input System lets you choose an input action from a pre-defined list, e.g. cabinet switches Constant sets the switch once at the beginning of the game to the given value. Device lets you choose a switch device containing the switch. Switch devices are mechanisms that include multiple switches, for example troughs . Element The Element column is where you choose which element triggers the switch. For Playfield sources, you can choose a game item that triggers switch events. Currently, VPE only emits switch events for items that would do so in real life, i.e. bumpers, flippers, gates, targets, kickers, spinners and triggers. Note We realize that you might want to use other game items like ramps and walls to emit switch events as well, and we will address this at some point, but for now we're keeping it simple. If Input System is selected, you choose which input action to use (it's an \"action\", because it's not an permanent key binding). Actions may have default key bindings, but the final bindings to a key or other input will be defined in the host application (the VPE player). If the source is a Device , then there are two values to select. The actual switch device, and which switch of that device should be connected to the gamelogic engine. Finally, if Constant is selected, you choose the value that will be permanently set at the beginning of the game. Pulse Delay Internally, VPE connects switches to events. For example, a trigger on the playfield has a Hit event, which occurs when the ball rolls into the trigger's collision zone, and an UnHit event when the ball leaves that zone. These two events close and open the trigger's switch. However, not all mechanisms behave like that. For example a spinner emits a single Spin event. So to prevent the switch from being closed indefinitely VPE automatically re-opens it after a given delay. We call that the Pulse Delay . \"Pulse\", because it gets triggered by one event and reopens after a brief delay. In most cases, you can leave the default delay of 250ms. What's important is that the gamelogic engine gets notified not too long after the switch was closed. Note that if pulse delay is set to 0, the switch will stay closed. Supported Game Mechanisms Below a list of game mechanisms that contain built-in switches. Closes Opens Bumper On ball collision After pulse delay Flipper On EOS, i.e. when the flipper reaches its end position When the flipper switch is opened, i.e. the flipper starts moving down again Gate When ball is passing through the gate When ball has passed through Target On collision After pulse delay Kicker When ball enters the kicker When ball's outside the kicker Spinner On each spin After pulse delay Trigger When the ball rolls over the trigger When the ball is outside of the trigger Runtime During runtime, you'll see the switch statuses update in real-time. Clicking on the icon manually toggles the switch, which can be handy for debugging."
  },
  "creators-guide/editor/unity-components.html": {
    "href": "creators-guide/editor/unity-components.html",
    "title": "Unity Components | VPE Documentation",
    "keywords": "Unity Components When loading or creating a table in Unity, what you're creating is a hierarchy of GameObjects , the basic building blocks of Unity scenes. By default we group game items by their type when importing, but you can arrange them however you want. To give the GameObjects behavior during gameplay, we add components onto them. VPE comes with a large number of components that are used to set up and control the game mechanisms of the table, and advanced programmers can contibute new ones. If you've never heard about GameObjects or components, we recommmend you read through the links in the first two paragraphs. They are short, to the point, and a much better introduction than we could provide here. Components vs Game Items In Visual Pinball , components are what you see in the options panel when you click on a game item. You'll typically find sections for adjusting physical behavior, visual display, and geometric shape of the game item you're editing. Internally, all of these sections belong to the same game item. In VPE , we have separate components for each of these sections. There are four different types of components: The Main Component represents the actual game item. A Collider Component adds physical behavior to the game item. It defines how the item interacts with other objects, for example what bounciness, friction and randomness is applied to a pinball hitting the item. Mesh Components generate meshes, i.e. the geometry used to render the object on the playfield. The results are the procedurally generated 3D objects rendered in the scene. Animation components apply movement to the game item. If the entire object is moving (for example a flipper), that is handled by the collision component, but for items where only parts move (e.g. the plate of a gate, or the ring of a bumper) these components apply the movement to the GameObject. Let's look at a flipper: Here, we see the main component ( Flipper ), the collider component ( Flipper Collider ), and two mesh components ( Flipper Base Mesh and Flipper Rubber Mesh ) inside VPE compared to Visual Pinball. While the main and collider component sit on the base GameObject, each mesh component is on its own child GameObject. This is how Unity works - a GameObject only contains one component of each type."
  },
  "creators-guide/editor/wire-manager.html": {
    "href": "creators-guide/editor/wire-manager.html",
    "title": "Wire Manager | VPE Documentation",
    "keywords": "Wire Manager Using the Switch Manager , you can wire playfield and cabinet switches to the Gamelogic Engine . Similarly, the Coil Manager and Lamp Manager let you connect playfield elements to the outputs of the Gamelogic Engine. The Wire Manager allows you to bypass the gamelogic engine and connect switches directly to coils and lamps. Using the dynamic wires, this can be used to eliminate the flipper lag often introduced by emulated ROMs. But it also can be useful for debugging, or for game logic that might not be covered by the gamelogic engine. You can open the wire manager under Visual Pinball -> Wire Manager . Setup Every row in the wire manager's table corresponds to a connection between a switch and an element that takes an input. You can connect multiple switches to one element or a single switch to multiple elements. In the following, we call the switch the source and the element it is connected to the destination . Description The first column Description is optional. It can help better organize all the connections, but can be left empty if you want. Source The Source column defines the type of source you are connecting to. There are four types: Playfield lets you select any game item that qualifies as a source from the playfield. Input System lets you select an input action from a pre-defined list, e.g. cabinet switches. Constant sets the destination to a constant value. Device lets you select a source device. Such devices are mechanisms that include multiple sources, for example troughs . Source Element The Source Element column is where you select which element acts as the source. For Playfield sources, you can select a game item that triggers switch events. Currently, VPE emits switch events for items that would do so in real life, i.e. bumpers, flippers, gates, targets, kickers, spinners and triggers. If Input System is selected, you select which input action to use. Actions may have default key bindings, but the final bindings to a key or other input will be defined in the host application (the VPE player). If the source is a Device , then there are two values to select. The actual source device, and which switch of that device should be connected to the gamelogic engine. Finally, if Constant is selected, you select the value that will be permanently set at the beginning of the game. This might me useful for lamps that are always on. Destination Under Destination you can select the type of the element that will receive the switch changes. There are two types to choose from: Playfield lets you select any game item that qualifies as a destination from the playfield Device lets you choose a destination device. Such devices are mechanisms that include multiple coils or lamps, for example troughs . Destination Element The Destination Element column is where you select which specific element in the destination column should receive switch changes. If Device was selected in the previous column, both the actual device and the element within the device have to be selected. Dynamic By checking the Dynamic box, the wire dynamically enables and disables depending on the gamelogic engine's output. Used with flippers, this feature is also known as Fast Flip and can be used to reduce the lag introduced by an emulated gamelogic engine like PinMAME. If it's enabled and a game is started, VPE compares the switches and coils linked to the gamelogic engine and tries to find the switch and coil IDs that correspond to the wire. If found, VPE monitors the coil signals of the gamelogic engine. If the time between the switch and the coil response is below a threshold, the wire is enabled and future coil signals from the gamelogic engine are discarded. In the same way, if the wire is active and no coil signal is received within the threshold, the wire is disabled again. Note In order to match the switch and coil signals from the gamelogic engine, the switch and the coil need to be linked to the gamelogic engine using the Switch Manager and Coil Manager respectively. For example, it's not sufficient to just create a flipper button -> flipper coil wire and not link the flipper button to the flipper switch and the flipper coil to the flipper. There are a few edge cases that are handled as well. For example, if the wire is active and the gamelogic engine enables the coil without a switch signal (like the Phantom Flip in Monster Bash), the coil event is not discarded (VPE internally keeps a queue of switch events and if the queue is empty, coil events are still processed). However, by design, there are two caveats: When the wire is inactive, the first event always has the gamelogic engine lag, since VPE will only activate the wire when it's sure a coil event is emitted. When the gamelogic engine stops emitting coil events, VPE continues emitting the coil event one more time until it discovers the absence of the coil event and thus sends the negative signal after the threshold to \"undo\" its mistake. Note MPF has a similar feature called Hardware Rules . This is the preferred way, because the gamelogic engine explicitly notifies VPE about which wires to add and remove during gameplay. However, other gamelogic engines like PinMAME don't have this feature, that's why VPE comes with the dynamic wire feature that guesses when wire is active and when not. Pulse Delay Internally, VPE connects switches to events. Some switchable game items only emit the switch closed event. Such items are spinners and targets. These are elements where the re-opening of the switch does not have any semantic value. In order for those to not stay closed forever, VPE closes them after a given delay. We call this the Pulse Delay . This field is only visible if the input source is a pulse-driven source. Runtime During runtime, you'll see the wire statuses update in real-time. Clicking on the icon manually toggles the wire, which can be handy for debugging."
  },
  "creators-guide/introduction/features.html": {
    "href": "creators-guide/introduction/features.html",
    "title": "Features | VPE Documentation",
    "keywords": "Features This section documents what's already working. If it's not, then that's a bug, and you should let us know . Materials We convert Visual Pinball's materials to materials compatible with the active render pipeline. That means materials look similar to Visual Pinball by default, while there's still a lot of potential left to tweak materials using the full material configuration of Unity. Bord's \"Viking\" rendered in VPX (left) and imported as-is in VPE's built-in renderer (right). Meshes Visual Pinball dynamically generates meshes for most of the game items. VPE has ported that code and does the same when loading a table. A rubber mesh generated in the editor Physics We have nearly finished porting Visual Pinball's physics engine to VPE. That means the ball and flipper behavior should be identical to Visual Pinball. This includes physics-based movement from flippers, gates and spinners, as well as animated targets, triggers and plungers. Events The physics engine emits the same events as Visual Pinball. That means you can subscribe to collision events and other game item-specific events. For example, for subscribing to the flip event of a flipper, you would do: table.Flipper(\"LeftFlipper\").LimitEos += (sender, args) => { // do something! }; Note While it's not clear how we'll handle scripting, most events can probably be configured visually in the editor and don't need to be handled via scripting. Cross Platform Unity supports a lot of platforms . Our continuous integration builds for Windows (x86/x64), macOS (x64) and Linux (x64). Besides Windows, some of our developers work on macOS, and we regularly test on Linux as well. File Format We care about backwards-compatibility to Visual Pinball. VPE can read and write .vpx files and supports the full data set. This means that you can load a table into VPE, edit it, export it to .vpx and load it back into Visual Pinball. Note VPE will at some point need to save additional data that isn't available in Visual Pinball. However, the .vpx structure is like a virtual file system, so we can do that without breaking backwards-compatibility. Editor Extensions Unity allows full editor customization. So we're adding the managers, panels, and toolboxes from Visual Pinball into the Unity editor: What you're seeing here is the toolbox as well as a few manager windows we've ported: Material Manager Image Manager Layer Manager Inspector acting as VP's Options Panel You can dock these as you wish, or even undock them and move them to another monitor. Not in the above screenshot but also ported are: Collections Manager Sound Manager VPE is also able to edit drag points. Moving those (in 3D!) re-generates the mesh on the fly: Lastly, we can visualize the colliders of any object. This can be useful to debug, and also to check whether you may have objects set to collide which actually shouldn't (or vice versa)! Patching System There are common patterns for VPX tables that are obsolete in VPE. For instance, VPE doesn't need a flipper shadow mesh, because it can do dynamic lighting out of the box. For that reason, we have a simple but sophisticated patcher system that allows us to apply changes to a table when imported. Of course the changes don't apply to the table data itself but to how we convert it into the Unity scene. You can read more about it here . Display Support VPE provides high-quality rendering of dot matrix and segment displays. Displays can be placed anywhere in the scene, multiple at once, and are easily linked to the game logic engine. For DMDs, dot size, shape and color can be customized, and for segment displays it's the segment weight, skew angle and color."
  },
  "creators-guide/introduction/overview.html": {
    "href": "creators-guide/introduction/overview.html",
    "title": "Overview | VPE Documentation",
    "keywords": "Overview The Visual Pinball Engine (which we call \"VPE\") is an open source pinball simulator that you can use to create pinball games for Windows, macOS, and Linux. It's based on the famous Visual Pinball (often abbreviated \"VP\", or \"VPX\" for its latest version 10) meaning VPE's physics simulation matches that in VPX, and it can read and write the same file format. VPE uses Unity for its underlying game architecture. Unity is one of the leading cross-platform game engines and provides VPE with an advanced render pipeline that produces high-quality visuals and is continuously maintained and updated to work with new hardware features. Unity also comes with an amazing editor, which VPE extends to make the table creation process as easy as possible. An imported .vpx file in VPE, using Unitys' High Definition Render Pipeline. Note Technically, VPE is what we call a \"library\". A library is not executable per se, because it needs a host application. We will provide such a host application in the future, but for now you will need to create a new Unity project and add VPE as a package in order to run it. Audience This documentation is mainly aimed at table creators (\"authors\"). Since it covers table scripting as well, it also contains code-related documentation. VPE is currently not in a state where it is usable by the general public (\"players\"). Documentation about how to setup VPE to play will follow at a later stage."
  },
  "creators-guide/manual/displays.html": {
    "href": "creators-guide/manual/displays.html",
    "title": "Displays | VPE Documentation",
    "keywords": "Displays Every pinball machine has one or more displays where the score and other important information is shown. In the 80s, mostly numeric 7-segment displays where used, which transitioned in the 90s to alpha-numeric 16-segment and dot matrix displays. A dot matrix display used in the late 90s - Photo © 2009 by ElHeineken VPE supports both segment displays and dot matrix displays (usually referred to as DMDs). During game play displays are driven by the Gamelogic Engine . VPE supports multiple displays per game. Note While the earliest electro-mechanical pinball machines used motorized score reels, and today's are using high resolution LCDs neither are yet supported in VPE. Setup Displays are lazily bound, meaning that when the game starts the gamelogic engine announces its displays and VPE connects them to objects in your scene that actually render them. Matching is done with an ID and depends on how the gamelogic engine being used manages displays. For example, in MPF you name your displays yourself in the machine configuration, while PinMAME uses IDs like dmd0 and display0 to identify its DMDs and segment displays. Editor VPE provides two display components, one for segment displays and one for DMDs. Both components create the underlying geometry and apply a shader that renders the content of the display. In order to create one, make an empty game object in your scene and add the desired component under Visual Pinball -> Display . You can also create the game object with a component already assigned by right-clicking in the hierarchy and choosing Visual Pinball -> Dot Matrix Display . This will place the display into your scene right behind your playfield. Selecting the game object will let you customize it in the inspector, and assign the ID that links it to the gamelogic engine. Runtime The inspector allows you customize parameters controlling the geometry of the display like DMD resolution or number of segment columns in the editor. This is useful, because it allows you to see the correct geometry without running the game and place the display where it fits in the scene. However, during runtime these parameters are provided by the gamelogic engine and the displays will be reconfigured as soon as they are received. This means that if you've set the wrong number of chars in your segment display, it will be resized at runtime and look different than the version in the editor. Note There are additional settings that don't affect geometry that aren't configurable in the editor but will be automatically set during gameplay, such as number of segments per column."
  },
  "creators-guide/manual/gamelogic-engine.html": {
    "href": "creators-guide/manual/gamelogic-engine.html",
    "title": "Gamelogic Engine | VPE Documentation",
    "keywords": "Gamelogic Engine When playing a pinball game, some part of the table is driving the gameplay, i.e. deciding when to flip a coil, turn on a light, show something on the DMD, and so on. In VPE, we call this the Gamelogic Engine . The gamelogic engine is purely gameplay driven. It gets input from switches, computes what will happen next, and updates the hardware components of the table. It does not handle game mechanics, which are about simulating the hardware behavior of the table - it just toggles it. Classic examples of gamelogic engines are MPF and PinMAME . Note Let's take a spinning wheel on the playfield as an example. The game logic engine's job is to know when to turn it on and off. The game mechanics component of the spinning wheel is about rotating the actual playfield element with the right speed, acceleration, and handle ball collisions with a given friction. At the moment it's still unclear how VPE will deal with game mechanics. Initially, we will ship a bunch of game mechanics ready to use, and the future will tell how authors can create their own. In Visual Pinball, the gamelogic engine is part of the table script, which in most cases uses VPM to drive the game. So a part of the table script is about piping data into VPM and handling its outputs (lamp changes, coil changes, and so on). Since VPE defines a clear API (like a contract) between the table and the gamelogic engine, we can provide tools to make this easy for you. Currently, VPE provides: A Switch Manager A Lamp Manager A Coil Manager These tools provide a graphical user interface where you can link playfield elements to the gamelogic engine and configure them. Ultimately, that means if your table uses an existing gamelogic engine like MPF or PinMAME, and the table doesn't contain any exotic game mechanics, that's all you need to do. You can set up your table without a single line of code!"
  },
  "creators-guide/manual/manual.html": {
    "href": "creators-guide/manual/manual.html",
    "title": "Manual | VPE Documentation",
    "keywords": "Manual This section will document the following: Game Items Pinball Mechanisms Scripting Physics Plugins"
  },
  "creators-guide/manual/mechanisms/collision-switches.html": {
    "href": "creators-guide/manual/mechanisms/collision-switches.html",
    "title": "Collision Switches | VPE Documentation",
    "keywords": "Collision Switches A Collision Switch turns a hittable game object into a switch device. Examples of hittable game objects are walls, rubbers, and primitives. Setup To create a Collision Switch: Add the collision switch directly to a hittable game object. Select the game object you want to add it to, click on Add Component in the inspector and select Visual Pinball -> Mechs -> Collision Switch . To associate the collision switch with a game logic engine switch, use the Switch Manager and select the switch in the Element column: Runtime During gameplay, the inspector shows you the status of the switch."
  },
  "creators-guide/manual/mechanisms/drop-target-banks.html": {
    "href": "creators-guide/manual/mechanisms/drop-target-banks.html",
    "title": "Drop Target Banks | VPE Documentation",
    "keywords": "Drop Target Banks A Drop Target Bank is a collection of one or more drop targets that are reset (raised) when a coil is fired. Setup You can create a Drop Target Bank in two different ways. If your game has a single bank drop target, or multiple single bank drop targets, it is preferred to add it directly to the drop target. Select the drop target you want to add it to, click on Add Component in the inspector and select Visual Pinball -> Mechs -> Drop Target Bank . If your game has drop target banks with multiple drop targets, click on Drop Target Bank in the toolbox. This will add a Drop Target Banks hierarchy to the playfield and create a new GameObject with the right component assigned. To configure the drop target bank, select the total number of drop targets from the Banks drop down. Then, under Playfield Links , select each drop target belonging to the bank. To configure the reset coil, use the Coil Manager and associate the corresponding game logic engine coil with the Reset Coil exposed by the drop target bank: Runtime During gameplay, the inspector shows you switch information for each of the drop targets. You can also drop or reset a drop target by using the Drop and Reset buttons. To test resetting a drop target bank from the Coil Manager , click the icon next to the corresponding reset coil."
  },
  "creators-guide/manual/mechanisms/flippers.html": {
    "href": "creators-guide/manual/mechanisms/flippers.html",
    "title": "Flipper | VPE Documentation",
    "keywords": "Flipper How flippers interact with the ball is what makes or breaks a pinball simulation. A few years ago, a community member named Mukuste spent time on improving Visual Pinball's flipper mechanics. The result was what has become known as the physmod , which provided a much more realistic simulation, and was later merged into Visual Pinball's main branch. In his own words : Flippers are now simulated as true dynamic rigid bodies which have forces from the solenoid, the return spring and the ball acting on them and accelerate accordingly. They will also properly bounce off their stoppers instead of just moving to maximum extension and then stopping. In practice, this means that flipper/ball interaction is now much more realistic and less binary. Post passes, light taps, cradle separations, drop and live catches are now all possible. Furthermore, the simulation of the friction of the flipper rubbers greatly improves aiming. Later, another member of the community named nFozzy managed to measure ball trajectory angles on real pinball machines, and developed a script where authors could provide a profile that would slightly adjust the ball trajectories during game play to match his measurements. This resulted in tables with the most realistic flipper behavior the community has produced yet. VPE's default flipper behavior is identical to Visual Pinball's. However, VPE also provides native support for the nFozzy adjustments. Setup The easiest way to create a flipper is clicking on the flipper icon in the toolbar. This will instantiate a flipper prefab and place it on the playfield. Mesh VPE provides a procedurally generated flipper mesh. It consist of a base mesh (the plastic bat), and a rubber mesh . It's possible to provide a custom mesh for the flipper by replacing the game objects used to generate the procedural meshes. However, the physics simulation will still use the original colliders, so make sure to adapt the parameters to match the custom flipper's dimensions. Physics Adding the Flipper Collider component to the flipper makes it part of the physics simulation. Here you can tweak the various parameters. Most of the following is taken directly from Mukuste's Wiki . Mass This is the mass of the flipper (where 1 corresponds to standard ball mass, 80g). It basically describes how much the flipper interacts with the ball. A very heavy flipper will barely feel the impact of the ball and keep moving at almost the same velocity as it was before the contact. A very light flipper, on the other hand, will move more slowly with the ball on it than it does without, and will be significantly deflected by the impact of a ball. Strength This is the force (actually torque) with which the solenoid accelerates the flipper. The higher this value, the faster the flipper will move. Be aware that this is directly linked to flipper mass; if the flipper is twice as heavy, it also needs twice the force to get it to accelerate at the same rate. Elasticity and Elasticity Falloff This is basically the bounciness of the flipper rubber. Since real rubber is less bouncy when it is hit at a higher velocity, the Falloff parameter allows decreasing the elasticity for fast impacts. A value of 0 for falloff means no falloff, i.e. elasticity is independant of velocity, and a value of 1.0 means that elasticity is halved at an impact velocity of 1 m/s. Friction This describes how much the rubber \"grips\" the ball. This value is very important for enabling center shots on the playfield with a moving ball, as well as backhands. In general it affects the aiming on all shots, but also makes a spinning ball deflect off the flipper in the proper direction. Return Strength Ratio This is the force of the return spring which pulls the flipper back down, relative to the solenoid force which pulls the flipper forward. For instance, at 0.10, the force of the return spring will be 1/10th of that of the solenoid. Due to how acceleration and velocity work, the time the flipper needs to return to its home position is about three times longer than that for the forward stroke in this example (square root of 10, to be precise). If you make this smaller, not only will the flipper return slower, but it will also pick up less speed if you briefly release the flipper and then press it again since it has less time to accelerate. A smaller value therefore makes it easier to do flipper tricks which involve light taps, such as cradle separations and flick passes. Coil Ramp Up This simulates the fact that the magnetic field in the flipper solenoid takes a while to build up when the flipper button is pressed, and to fall off again when the button is released (also known as hysteresis). This means that the flipper will not have its full acceleration immediately as the coil needs some time to ramp up to the full magnetic field. At a value of 0, there is no ramp up, and the full acceleration takes effect immediately. At a nonzero value, this is the relative time the solenoid needs to reach its full acceleration. For instance, if set to 3, the flipper coil will take around 30 ms to ramp up to full force. Gameplay-wise, the effect of this parameter is most strongly felt in situations where the flipper button is pressed only for a very short time, or released for a short time and then pressed again. In other words, it will make light taps much easier and therefore help with moves such as cradle separations and flick passes. Even tap passes can be achieved with the proper setting. Note that increasing this setting will decrease the speed of the flipper a bit and may need to be compensated with a higher Strength setting. Also, if this parameter is set too high, the flipper may feel sluggish and laggy. EOS Torque and Angle The \"end of stroke\" torque is the force that holds the flipper up once it reached the end position. The angle defines how many degrees from the end position that force is applied. Flipper Correction This is where you can set a profile for nFozzy's flipper physics. Profiles are files in your asset folder that you can create and modify. VPE ships with three profiles based on nFozzy's measurements that cover the solid state era of pinball machines. EM machines usually don't need flipper correction. Clicking on a flipper correction profile in your project window shows this in the inspector: You can see that it consists of two curves, one describing the corrected velocity magnitude, and one the corrected x-axis of the velocity. Both curves are relative to ball position on the flipper, and normalized to the flipper length. Additionally, there is a threshold in milliseconds since the flipper was fired, after which no corrections will be applied. You can tweak these curves by clicking on them in the inspector. However you cannot edit VPE's default profiles directly, you must copy it to the table's asset folder first (and of course, assign the new copy to your flippers). Polarity Correction Curve Velocity Correction Curve When applying one of default profiles, you should also adjust the flipper parameters in order to obtain realistic ball behavior. We've also added a column with good values for EM machines that don't need correction. Late 70s to mid 80s Mid 80s to early 90s Mid 90s and later EMs Mass 1 1 1 1 Strength 1400-1600 (1500) 2000-2600 3200-3300 (3250) 500-1000 (750) Elasticity 0.88 0.88 0.88 0.88 Elasticity Falloff 0.15 0.15 0.15 0.15 Friction 0.9 0.9 0.9 0.8-0.9 Return Strength 0.09 0.07 0.055 0.11 Coil Ramp Up 2.5 2.5 2.5 2.5 Scatter Angle 0 0 0 0 EOS Torque 0.3 0.275 0.275 0.3 EOS Torque Angle 4 6 6 4 Common Gotchas Flipper Length A common mistake is incorrect flipper length. A 3-inch flipper with rubbers will be about 3.125 inches long. This translates to about 147 VP units. Therefore, the flipper start radius + the flipper length + the flipper end radius should equal approximately 147 VP units. -> API Reference"
  },
  "creators-guide/manual/mechanisms/light-groups.html": {
    "href": "creators-guide/manual/mechanisms/light-groups.html",
    "title": "Light Groups | VPE Documentation",
    "keywords": "Light Groups Sometimes, a game addresses multiple physical lights as one logical lamp, i.e. all lights are always toggled or faded at the same time. Typical use cases are GI strips . Instead of creating a link in the Lamp Manager for each light separately, VPE ships with a component called Lamp Group . A light group is a component you can add to any GameObject. It's recommended to make it parent of the light objects it contains, but you can also keep it outside of the lights hierarchy, since it explicitly references the lights it contains. Setup To create a new light group, select the GameObject you want to add your light group to, and in the inspector click on Add Component and choose Visual Pinball -> Game Item -> Light Group . Then use the list control to add and remove lights. There are a few buttons that make this easier. Add Children In case you have parented the light groups component to the light GameObjects it should include, this button adds all child lights to the list. Existing lights will remain. Replace With Children Similar to Add Children , only that the list is cleared before adding new lights. Clear Simply clears the list. Select Light Sources When working with lights, the GameObject with the actual light source is nested within the main object. This can make adjusting light settings for multiple lights tedious, since you have to drill into each parent in order to select the source. This button selects all the source GameObjects for the lights in the light group."
  },
  "creators-guide/manual/mechanisms/rotators.html": {
    "href": "creators-guide/manual/mechanisms/rotators.html",
    "title": "Rotators | VPE Documentation",
    "keywords": "Rotators Sometimes during gameplay, you might need to rotate objects in order to recreate certain mechanisms. Like Visual Pinball, VPE doesn't support dynamic colliders (yet), but visually, objects can still be rotated. Rotators in VPE are components that allow you to easily rotate objects around the Z-axis. The Rotator component is applied to a target , which will then rotate around its local origin (typically the position on the playfield). Additional objects can be linked to rotate around the same axis at the same time. Setup In order to create a rotator, add the Rotator component to a game object by clicking Add Component in the inspector, then choosing Visual Pinball -> Game Item -> Rotator . You can use any game object, although we recommend adding it to the target that you want to rotate. Target Just adding the component to your target game object won't automatically rotate the target. You need to explicitly assign it in the Target field. Rotate With Add other objects that rotate along with your target here. Currently, the following game items are supported: Primitives - Apart from the position, the object rotation of the primitive is updated. Note that in case your primitive has collision enabled, the colliders will not rotate along with the rendered object. Kickers - Rotating kickers applies the new angle to the kicker coils, and if a kicker contains a ball, the ball is rotated along as well. Flippers - Rotating flippers updates the start angle of the flipper. Usage When adding a Rotator component to a game object, it provides a float input that other components can use to rotate the object. Currently, only the step rotator mech makes use of this input. However, the step rotator will probably be replaced by a more generic system soon, so we won't go into more details here."
  },
  "creators-guide/manual/mechanisms/slingshots.html": {
    "href": "creators-guide/manual/mechanisms/slingshots.html",
    "title": "Slingshots | VPE Documentation",
    "keywords": "Slingshots Slingshots are most commonly located just above the flippers. They usually consist of two \"blade\" switches on the inner side of a triangular rubber. Between the switches there is a coil driven arm that propels the ball away from the slingshot when either switch closes. Visual Pinball doesn't have an explicit slingshot element. Instead, it relies on walls with a segment marked as slingshot , which generates an additional force being applied to the ball when the segment is hit. However, the rubber animation is up to the table script to implement. VPE does provide a slingshot component that implements the rubber animation during runtime. This allows for functional slingshots without any additional code. However this approach isn't ideal and will be replaced with a proper slingshot element in the future. Setup Slingshot Wall In order to trigger the animation, the slingshot component needs a reference to the wall which has one of the control points set to slingshot . Rubbers VPE animates the control points of the rubber by interpolating between a start position to an end position and then back to the start over the duration of the animation. To set the start and end positions of the control points, we reference two rubber elements (which must have the same number of control points.) In the inspector, Rubber Off indicates the rubber representing the start position, and Rubber On the end position. Note In VPX, tables often come with three rubbers elements that are toggled in order to fake an animation. When using VPE's slingshot component, you can delete the rubber at mid position, since only the start and end rubbers are used. The interpolation is calculated in real time depending on the speed of the slingshot. Coil Arm On physical machines, the rubber is moved by an arm attached to the coil. VPE can simulate the movement of that arm by rotating a primitive across the X-axis. In the Coil Arm field, a reference to the primive can be set, and the total angle of rotation under Arm Angle . Animation The animation has two parameters: The duration in milliseconds, and the curve. The curve represents the position in function of time and covers both directions of travel. This allows non-linear movement of the rubber. Test With the test slider you can easily preview how the rubber and arm are animated. Howto Set Up a Slingshot from an Imported Table This howto uses the blank table, but other tables should be similar. Usually, slingshots consist of three rubbers for the animation, plus a wall for the physics. We need the following elements: The wall with a segment set to slingshot The rubber at idle position The rubber at activated position Optionally, the coil arm that pushes the rubber Note that both rubbers must have the same number of drag points. This is because during the animation, the rubber is linearly interpolated between the two drag points positions, which isn't possible if the number differs. When converting a table from Visual Pinball, that means that you may need to add additional drag points to the rubber at idle position. 1. Identify and clean up the elements Zoom in to the slingshot you want to set up. You'll probably want to temporily hide the plastic that covers up the rubbers and the wall. Find the rubber at idle position and at activated position. Delete the rubber in-between, we don't need that one. Note the names of those rubbers. Here it's LSling and LSling1 . Also look for the the coil arm, which is called Sling2 , as well as wall that acts as the physical slingshot, here LeftSlingShot . 2. Add additional control points if necessary Now, since LSling1 is bent and thus contains three additional control points, we'll add the same points to LSling . We can now also can hide the meshes of the rubbers. 3. Add the slingshot component In the Toolbox, click on the Slingshot icon, which will create a new element in the scene. Rename it and link the elements we've identified in step 1: Slingshot Wall links to LeftSlingShot Rubber Off links to LSling Rubber On links to LSling1 The slingshot component is now able to create the mesh. The animation can be tested with the Test slider. 4. Setup the coil arm animation Since the rubber is pushed inside by the arm, the arm should be animated along with the rubber. This can be a bit fiddly, since the arm should be as close to the rubber as possible without clipping through it. Move the Test slider all to the right, and play with the X-Rotation of the coil arm. Once you're happy, copy the angle to the clipboard. Then, select the slingshot. In the inspector, set the following fields: Coil Arm links to the primitive, in our case Sling2 . Arm Angle is the angle when the coil is enabled. Paste the angle you've copied before. Now, when moving the Test slider, the arm should animate along with the rubbers. 5. Wrap-up and test Before final testing, there are two things left to do: Select the coil arm and disable the collider Enable the plastic we hid in step 1. Then hit play and have a game!"
  },
  "creators-guide/manual/mechanisms/teleporters.html": {
    "href": "creators-guide/manual/mechanisms/teleporters.html",
    "title": "Teleporters | VPE Documentation",
    "keywords": "Teleporters Sometimes it's easier to teleport the ball from one place to another instead of setting up the physical environment to simulate the actual movement. VPE provides a simple component that destroys a ball at kicker A and creates a new one at kicker B. Note Please note that you shouldn't be using teleporters when the ball is visible, because it breaks the natural flow of the ball and looks choppy. Setup In order to create a new teleporter, select the GameObject you want to add it to, click on Add Component and select Visual Pinball -> Game Item -> Teleporter . You can choose any GameObject, although we recommend putting it on same GameObject as the source kicker. Note The teleporter's features are very basic. If there is need, we will add more features like teleportation to multiple types of game elements or the possibility to teleport in both directions. Eject After Teleport Once the ball is created at the destination kicker, it can be ejected immediately or after a delay (see next section), or it can stay in the kicker. If disabled, this option makes the destination kicker keep the ball until it's explicitly ejected through the kicker's coil. Wait Before Eject You should use teleporters only for trajectories that are hidden and that emulate a physical ball going from A to B. In that case, the time it would take for the ball to travel from A to B can be simulated by waiting for the destination kicker to pop out the ball. This is the time in seconds that is waited before the ball is ejected from the destination kicker, but only if Eject After Teleport is enabled. From Kicker A reference to the source kicker. Note that if you use this kicker for teleportation only, it's recommended to remove any coils from the kicker, since it will make it easier to select the right element when linking to it in the Coil Manager. To Kicker The destination kicker. Here you also select a coil in case the ball is ejected after teleportation."
  },
  "creators-guide/manual/mechanisms/troughs.html": {
    "href": "creators-guide/manual/mechanisms/troughs.html",
    "title": "Troughs / Ball Drains | VPE Documentation",
    "keywords": "Troughs / Ball Drains If you are unfamiliar with ball troughs, have a quick look at MPF's documentation , which does an excellent job explaining them. VPE comes with a trough mechanism that simulates the behavior of a real-world ball trough. This is especially important when emulating existing games, since the gamelogic engine expects the trough's switches to be in a plausible state, or else it may have errors. Creating a Trough When importing a .vpx file that doesn't have any troughs (which is likely, because Visual Pinball doesn't currently handle them in the same way as VPE) or creating a new table, VPE will automatically add a main trough to the root of the table. In order to create a trough manually, click on the Trough button in the toolbox. Linking to the Playfield To interact with the game, you must set up an input switch to drain the ball into the trough, and an exit kicker to release a new ball from the trough. This terminology may seem weird, since the ball exits the playfield when draining, but from the trough's perspective, that's where the ball enters . You can setup these links under Playfield Links by selecting the trough in the hierarchy panel and linking them to the desired items using the inspector. Note Both the input switch and the exit kicker are not related to the gamelogic engine. Their goal is purely to link the physics simulation to the trough logic, whose behavior is not physically simulated. Many games do have an input switch (which we call drain switch ) and an exit kicker (we that one eject coil ). They are simulated by the trough itself and show up in the switch- and coil manager under the trough device. The inspector also lets you configure other options: Ball Count defines how many balls the trough holds when the game starts. Switch Count sets how many ball switches are available. This is usually the same number as the ball count. The drain switch and the jam switch are excluded from this count. Has Jam Switch defines if the trough has a jam switch. This switch is often called eject switch as well. Roll Time sets how long it takes the ball to roll from one switch to the next. Kick Time defines how long it takes the ball to get kicked from the drain into the trough. Transition Time is only relevant for opto switches and defines how long the switch closes between balls. Trough Types VPE supports several variants of troughs found on real machines. You can configure the behavior of the trough by changing the Type in the inspector when the trough is selected in the hierarchy. In this section we'll again link to the excellent MPF documentation explaining each of the different types. We'll also provide an animation of the trough inspector during gameplay showing how the switches and coils behave in real time. Modern Mechanical Modern troughs with mechanical switches are covered by this type. The ball drains from the playfield directly into the ball stack, and every ball slot has an associated switch. When a ball gets ejected, the remaining balls move down simultaneously to the next position. During that movement, their switches get first opened and then closed again when they reach the next position. The time of this movement is defined by Roll Time . The animation on the right shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball, rolling back onto the stack. Modern Opto Modern troughs with optical switches work similar similar to their mechanical counterparts. However there are two differences: Opto switches have the inverse value of mechanical switches. That means per default, an opto switch is closed , and when a ball rolls through, it opens. It's kind of logical, because the ball blocks the beam of light thus opening the circuit, while a mechanical switch gets closed by the ball's weight. Timings are different. When a ball approaches an opto switch, the switch gets triggered as soon as the ball's front hits the beam, while a mechanical switch gets triggered when the ball's center is over it. This results in very short closing times when the ball stack moves to the next position after a ball eject. We call this closing time the transition time - it's the time during stack transition when all switches briefly close. Like before, the animation shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball, rolling back onto the stack. Note When a transition time is set to 0 , only the first and the last switch of the stack change value (as opposed to each position opening and closing immediately). Two coils and multiple switches Troughs of this type can be found in older machines from the 80s and early 90s. They consist of two parts: A drain, the ball rolls into when leaving the playfield A ball stack, where the out of play balls are held. In terms of switches, they still include a switch per ball in the stack, but also an additional drain switch to trigger kicking the ball from the drain into the stack. The animation shows a 6-ball trough filled with three balls. It starts by ejecting a ball, followed by draining that ball. The ball stays in the drain until the entry coil activates, which makes the ball roll over to the ball stack. Two coils and one switch A trough can also have only one switch in the ball stack. Instead of a Switch Count like the previous types, you select a Switch Position , which is the position in the ball stack at which the ball farthest away from the eject coil sits. The animation shows a 6-ball trough filled with six balls. It starts by ejecting a ball, followed by draining that ball. The ball stays in the drain until the entry coil activates, which makes the ball roll over to the ball stack. Classic single ball A single ball trough may work with or without a shooter lane. The principle is simple: After draining, the ball is kept on the drain coil, which ejects the ball either directly into the plunger lane or back onto the playfield. The animation shows single ball trough that ejects a ball and drains it a few seconds later. Switch Setup The number of simulated switches in the trough depends on the type of trough and the Switch Count property in the inspector panel. For recreations, you can quickly determine the number of trough switches by looking at the switch matrix in the operation manual, it usually matches the number of balls installed in the game. To configure the switches, open the switch manager and add the trough switches if they're not already there. For Destination select \"Device\", under Element , select the trough you've created and which switch to connect. For a modern five-ball trough, it will look something like this: Coil Setup VPE's trough supports up to two coils, an entry coil which drains the ball from the outhole into the trough, and an eject coil which pushes a new ball into the plunger lane. To configure the coils, open the coil manager , find or add the coils, and link them to the trough like you did with the switches: Note Depending on which trough type is set, different coils and switches show up under the trough device."
  },
  "creators-guide/setup/installing-vpe.html": {
    "href": "creators-guide/setup/installing-vpe.html",
    "title": "Installing VPE | VPE Documentation",
    "keywords": "Installing VPE Unity In order to start creating or modifying tables with VPE, the first thing you'll need to do is install Unity . You will need a Unity developer account, which is free. Note As long as you don't use Unity for a game that makes $100K or more in revenue or funding a year, the free Personal plan is sufficient for you. Unity uses an application called Unity Hub to update itself, create new projects and provide quick access to them. The install process is straight-forward and documented here if you run into troubles. When installing Unity, use the latest 2021.2 version. You can leave all the other options unchecked. Once Unity is downloaded and installed, you're ready to create a new VPE project. Click on New Project , be sure to have selected the 2021.2 version at the top, and you'll see the following choices: The relevant options for VPE are: 3D - Unity's original built-in renderer. 3D (URP) - Unity's Universal Render Pipeline is aimed at mobile and low-end platforms. 3D (HDRP) - Unity's High Definition Render Pipeline used for high-end platforms. We recommend using HDRP. It's what we're using when developing and should be the most stable pipeline. Alternatively if you're on a laptop don't have a beefy GPU, use the URP. The built-in renderer is legacy not recommended. Next, enter a project name and a location for your project. We recommend putting the render pipeline into the name, because in the future you might want to test out other pipelines in their own projects. Clicking Create project launches the Unity editor, pulls in all the dependencies for the new project, and compiles them. This will take a few minutes. HDRP Setup Once the editor has opened you can click away the HDRP Wizard that opens. You should now see an empty scene: Click on File -> New Scene and select the Basic Indoors (HDRP) template. Save it in your Assets/Scenes folder as TestTable.unity . In this base scene there's a Plane that will Z-fight with our imported table later. Select it in the Hierarchy and move it down a little by setting the Y Position under Transform in the Inspector to -0.1 . Your scene should now look like this: Hit Ctrl+S to save your scene. VPE Package Now that you have your project and scene set up, let's bring in the VPE libraries. VPE ships as a package that you can install using the Package Manager inside of Unity directly. However, since Unity's package registry is only used for official Unity content, we need to add our own registry first. To do that, go to Edit -> Project Settings , and select the Package Manager panel on the left. Under Scoped Registries , add the following: Name: Visual Pinball Engine URL: https://registry.visualpinball.org/ Scope(s): org.visualpinball Also check Enable Pre-release Packages (and confirm), as well as Show dependencies . Your settings page should now look like this: Hit Save and close the window. Now you'll add VPE's HDRP package, which will automatically pull in the core package and the assets package. Open the package manager by clicking on Window -> Package Manager . Then click on the \"plus\" icon on the top left corner of the window, and choose Add package by name.. . There, enter org.visualpinball.engine.unity.hdrp and click Add . This will take a moment as Unity downloads and compiles all of VPE's dependencies and parses all the assets that we ship in our library. If during this time, you see the following warning about the input system: Click Yes . Warning Our patcher, which is currently part of the main package, depends on the PinMAME package. Until we move the patcher into a separate package, you will have to install the PinMAME package as well. To do that, click on the plus button again and enter org.visualpinball.engine.pinmame , then click on Add . When complete, you should now have a Visual Pinball menu in the editor, and you should see the following new packages in the package manager (version numbers will vary): Now that VPE is installed let's import a table !"
  },
  "creators-guide/setup/running-vpe.html": {
    "href": "creators-guide/setup/running-vpe.html",
    "title": "Running VPE | VPE Documentation",
    "keywords": "Running VPE Now we can get begin with some simple game play. Open Visual Pinball , create a new \"blank\" table, and save it somewhere. In Unity, go to Visual Pinball -> Import VPX and choose the .vpx file you've just created. You should now see Visual Pinball's blank table in the Editor's scene view: Now, we don't see much of our table. That's because the scene view's camera doesn't really point on it. Using the right mouse button in the Scene View and the A W S D keys while keeping right mouse button pressed, fly somewhere you have a better view of the table. Tip Check Unity's documentation on Scene view navigation for a more complete list of ways to move the camera around the scene. Now that we have the camera of the scene view somewhat aligned, we still can't see much! These orange artifacts are what Unity calls Gizmo Icons . They are enabled by default, and since VPE uses icons for its playfield elements, they are all over the place. Unity's default gizmo size is adapted for rather large scenes and we're dealing with a pinball table, let's make them smaller by clicking on the gizmo icon in the Scene view, and pull the size 3D Icons slider down until you're happy. You can additionally hide the VPE icons by clicking on Visual Pinball -> Editor -> Disable Gizmo Icons . And while we're at it, choose Visual Pinball -> Editor -> Setup Layouts to populate a bunch of pre-made editor layouts that give you easy access to the tooling we've added to the editor. Then, click on the top right drop down in the editor where it says Default , and choose 3) VPE Simple . Now that's better! The view in the scene tab is not the camera used in game. The Scene View really allows you to fly anywhere, zoom in on things you're working on, switch from orthagonal view to perspective, and so on. It's where you get work done. During game play, another camera is used. It's the one already in your scene hierarchy (called Main Camera ), and you can look through it by switching to the Game View window. This camera can be moved using Unity's gizmos , by selecting it in the hierarchy and moving and tilting it around. Tip A quick way to fix the game camera is to align it with the scene view camera. To do that, select the camera in the hierarchy, then click on the GameObject menu and select Align with view . Let's start the game by clicking on the play button. This will run your scene. Test that the shift keys move the flippers. ENTER will launch a ball. If you expand Table1 in the hierarchy and select the Trough , you can watch its status in the inspector in real time. Cool! You can also right-click on the scene view tab and select Maximize . Tip If you want to enter play mode more quickly, you can check the experimental play mode option described here . One last thing: The game view is pretty static now. You can change that by dropping an orbit script on the camera that lets you rotate and zoom in. If you're a Unity beginner, that would be your first exercise!"
  },
  "creators-guide/tutorials/index.html": {
    "href": "creators-guide/tutorials/index.html",
    "title": "Tutorials | VPE Documentation",
    "keywords": "Tutorials Create Realistic Looking Plastics"
  },
  "creators-guide/tutorials/relatistic-plastics/1-prepare-artwork.html": {
    "href": "creators-guide/tutorials/relatistic-plastics/1-prepare-artwork.html",
    "title": "Realistic Looking Plastics - Prepare Artwork | VPE Documentation",
    "keywords": "Prepare Artwork The goal of the first step is to prepare the artwork in a way it's easily exportable and can be re-exported without having to go through the other steps. We're going to use Adobe Illustrator for this. As mentioned in the introduction, we're aiming for a single texture that contains all plastics. The advantage is that this way, less texture data needs to be transferred to the graphics card and only one material instance must be instantiated. It also allows you to process everything together, versus having to repeat this workflow for every plastic separately. Step 1: Create Artwork There are many ways to create artwork. If you're working on an original game, you might draw it using a drawing software. For recreations where you have access to the physical machine, you might disassemble the plastics and scan them or take pictures with a good camera. If you don't have access to the physical plastics, you might get good sources by searching on the internet. Note If you're using a camera, be sure to remove any lens distortion with Camera Raw or similar software. For images found online, you will probably have to manually un-distort the image. For optimal quality, two things are important when dealing with source material not coming directly from a scanner: Distortion: You'll be extracting the 3D mesh from the outline of your 2D artwork. If the artwork is distorted, you won't be able to fit the plastic on the playfield. Colors: Since Unity is applying lights to the scene, the colors in the texture should be neutral. That means that lights that leak into the texture will negatively influence the final render. Once you have an image of the plastic, you need to decide whether you will be using it as-is, or whether you're going to redraw it. Depending on the type of artwork, redrawing might not possible or a huge effort, and \"cleaning it up\" in Photoshop will do it. The advantage of redrawing it is that you can produce arbitrary large textures and make the colors match perfectly. Note Speaking of colors, it's best to use PBR-compatible colors, meaning your texture shouldn't contain absolute blacks or whites, and the brightness of other colors should be at around 95% max. For black, we're using #272727 and for white #f4f5f0 . The T2 table we're using in this tutorial contains exclusively vector art, so we've created an .ai file per plastic: Note the pink outlines. They sit on a separate layer and can be easily toggled. They should contain drill holes for the screws as well, as they are visible due to the plastic being transparent and the ink actually sitting below the plastic. Since our first step is to create the texture, hide the outlines and save all your files. Note If you're using pixel-based sources for the plastics, don't worry about the outlines just yet. ;) Step 2: Arrange Artwork Now we have one file per plastic, we'll place them into a single document that we can render out as a texture. For this, create a new, square document in Illustrator. Depending on the size and number of plastics you might want to change this later but give it a width and height of 4096 pixels for now. Let's call it Plastics.ai . Since we're creating the texture, we don't need the pink outlines. So, before continuing, open all of your source files, hide them, and save them. As we might update our original files later, we won't copy and paste our plastics into this document but link them instead. In order to do this, go to File -> Place... and select all your plastics. Then arrange them in a way so there's as little white space as possible remaining. Note In order for the plastics to have a similar pixel density, we recommend keeping the proportional size of the plastics approximately the same, i.e., larger plastics should take more space than smaller ones. Your artboard should now look something like this: Note the Links toolbox that shows the individual plastic files. Also note the pink surfaces on the right, outside the artboard. These are plastics that don't have any artwork, i.e., blank, transparent pieces. We keep them here because we want to generate meshes as well, but don't need it in the texture, which is defined by the artboard. Warning Verify that the outlines on the artboard are hidden. This is the version we'll create the texture with, and we don't want to leak the outlines onto the final texture. Step 3: Export Texture and Outlines We'll first export the texture. In Illustrator, click on File -> Export -> Export As... , and make sure Use Artboards is checked. As type, select PNG . Then, enter Plastics.png as file name and click on Export , which will result in the dialog seen in the screenshot. Since you've set the resolution to 4096 × 4096 pixels when you've created the document, and the default pixel density is 72dpi, choose 72dpi. This should result in a PNG file at 4096 × 4096 pixels. Note When I exported it when writing this tutorial, Illustrator exported it as 4097 × 4097 🤦‍♂. So, I ended up exporting it with a slightly higher resolution and sizing it down in Photoshop. Outlines The goal of having outlines in the artwork is so that we can extract the mesh from it, and it allows us to align the artwork perfectly on the surface. We're going to export the outlines as solid surfaces in the SVG format. The result we can then import into Blender. In order to do that, open all your artwork files, hide the actual artwork, and only show the outline. Make it one single solid surface per plastic , meaning if you have holes, you need to remove them from the parent curve. Note If your artwork are pixel graphics, draw your outlines directly into Plastics.ai . We recommend putting them on a separate layer, so you can toggle them easily. Your document should now look like this: Don't worry about the color, it just needs to be filled in any color. I'm using magenta because it gives a good contrast to the rest of the artwork. Click on File -> Save a Copy... , enter Plastics.svg as file name, save as type SVG and make sure Use Artboards is unchecked this time. Click on Save . In the options panel, click on More Options and make sure all the options are disabled as shown in the screenshot. You're now ready to create the meshes ."
  },
  "creators-guide/tutorials/relatistic-plastics/2-create-mesh.html": {
    "href": "creators-guide/tutorials/relatistic-plastics/2-create-mesh.html",
    "title": "Realistic Looking Plastics - Create Mesh | VPE Documentation",
    "keywords": "Create Mesh We're now going to import the SVG created in the previous step and create a mesh that is beveled on the top. Step 1: Import Open Blender, clear the scene with A , X , Enter . Then, click on File -> Import -> Scalable Vector Graphics (.svg) , navigate to where you've saved the SVG in the previous step, select Plastics.svg , and hit Import . You might not see much due to the imported size. If there were no errors, you should see your imported plastics in the Outliner. Select them and press . on the numpad (not the main keyboard) while hovering over the 3D viewport to zoom in. Note You might run into another issue due to the size of the plastics: Camera clipping. To fix that, press N with your cursor over the 3D Viewport, select View and set something like 0.001m for Clip Start . Your viewport should look like this now: Step 2: Setup The way we're going for this is to extrude and bevel our SVG on one side only. This however results in the bottom faces missing. To fix that, we'll duplicate our SVG and use one for extrusion and the other for the bottom mesh. Before we start, let's make it one single object so we can easily apply everything we do in one step. Select one element, hit A for select all, then Ctrl + J for joining all curves. Hit Shift + D , Esc to duplicate at the same position. In the Outliner , let's name our objects \"bottom\" and \"extruded\": Step 3: Extrude Select \"extruded\" in the outliner and click on the Object Properties tab in the Properties view on the right side. Under Geometry , there is an Extrude field, and a bit below a Bevel section. Now, the Extrude value is difficult to judge. If you have access to the physical plastics, you can calculate the scale between the real world and the object in Blender by physically measuring the size of a plastic and dividing it by the measured value in Blender. Then, also measure the thickness of the real-world plastic and multiply it by that factor. Personally, I just eyeballed it and ended up with 0.003 m for the Extrude value and 0.001 m for the Bevel Depth . Then there are three more properties to change: We only want to extrude the front, so set Fill Mode to Front . We don't want to make the object larger by beveling, so enter the negative value of the bevel depth under Offset . Finally, a Resolution of 0 will do. Here are all the non-default options in red: Step 4: Convert, Join and Clean As seen in the previous screenshot, our bottom object now sits in the middle of the extruded mesh. Let's fix that by typing G (move), Z (on z-axis only), and the extrude value of the previous step, in our case 0.003 , followed by Enter . Then type A to select all objects, choose Object -> Convert -> Mesh , and hit Ctrl + J to join them all. Finally, clean up the duplicated vertices from the extrusion by hitting Tab for edit mode, A to select all vertices, and choose Mesh -> Clean Up -> Merge by Distance . Exit edit mode and this is how it should look: If that's the case, congrats, you're done with the meshes! Maybe now it's a good moment to save your Blender file. Ctrl + S and enter Plastics.blend . In the next part of this tutorial, we're going to UV-Map them."
  },
  "creators-guide/tutorials/relatistic-plastics/3-uv-map-mesh.html": {
    "href": "creators-guide/tutorials/relatistic-plastics/3-uv-map-mesh.html",
    "title": "Realistic Looking Plastics - UV-Map Mesh | VPE Documentation",
    "keywords": "UV-Map Mesh Step 1: Create Material Slots We need three material slots, for the top and bottom faces, as well as for the edges. We'll split the vertices by firstly assigning everything to an \"edge\" slot, and then re-assigning the top and bottom faces to their own slots. In object mode, open Materials properties and remove the current material slot (hit - ). Add three new slots (press 3× + ), and for each slot, create a new material by hitting the New button when the slot is selected. Name them \"top\", \"bottom\" and \"edge\" and set their base color to red, green, and blue respectively. Your slots should now look like in the screenshot. Set the 3D viewport to Material Preview . Select your mesh, press Tab to switch to edit mode. Press A to select all vertices, select the \"edge\" material slot, and hit Assign . Your plastics should turn blue. Press A twice to deselect everything. Then, press 7 on the numpad to switch to top view, zoom in a bit so you can clearly see the triangles, switch to Face Select and click on one face of the top surface: Click on Select -> Select Similar -> Coplanar , which should result in all top faces of all plastics being selected (but not the bottoms ones). However, you might get the bottom faces selected too, because there's a threshold that might be too large. You can check it by rotating the camera and verify that the bottom faces are not selected. If they are, expand the parameters and set the threshold to a small enough value. Then, select the \"top\" material slot and hit Assign . The top surfaces should turn red. For the bottom faces, hit 7 , 9 on the numpad to switch to bottom view, and select again one face. Like before, select all coplanar faces, click the \"bottom\" material slot, and Assign . You should see the bottom faces turn green. Now, the \"edges\" material slot should only contain the edges. Check by unselecting all ( A A ), then selecting the \"edge\" material slot and hitting Select . This should only select the edges, like here: Your meshes should now be colored like this (from top / bottom): Step 2: UV-Map Switch to the UV Editing workspace. In the left UV Editor , choose Image -> Open , and select the exported Plastic-01.png you've created in part one. On the right, enter edit mode, click on the \"top\" material slot in the Materials property tab, and hit Select . Click on \"bottom\" and then on Select again. From the UV menu, select Cube Projection . Move your cursor to the left view and press A . You should see both the top and bottom surfaces projected onto your texture: We're now going to align the projection with the texture. You can do that by using the G and S keys. What's important is to align the outer contour with the texture, like so: Step 3: Prepare and Export Once done, switch back to the Layout workspace. Before we export, there's still a bit of a clean up to do. In edit mode, hit A to select all and choose Mesh -> Clean Up -> Limited Dissolve . Exit edit mode, go to Modifier Properties , add the Triangulate modifier, and hit Ctrl + A to apply. What we just did reduced the complexity of our topology. We triangulate at the end to avoid problems during export. From left to right: Original (102k vertices, 44k triangles) After limited dissolve (66k vertices, 30k triangles, but errors in mesh) After triangulation (66k vertices, 30k triangles) Switch to the Object Data properties, and under Normals , enable Auto Smooth . This will properly align the normals on the bevel side, giving it a more realistic refraction effect. We still have one single object, so before exporting, let's split it. In edit mode, hit A to select all and choose Mesh -> Separate -> By Loose Parts . Before exporting, feel free to rename your objects in the Outliner, it's what you'll see in Unity. Lastly, in object mode, hit A to select all objects and click on Object -> Set Origin -> Origin to Geometry . This will set the local origin of each object to the object itself, making it easier to place it. Export the plastics by selecting File -> Export -> FBX . Name it Plastics.fbx and hit Export FBX . Now let's import this into Unity !"
  },
  "creators-guide/tutorials/relatistic-plastics/4-import-into-unity.html": {
    "href": "creators-guide/tutorials/relatistic-plastics/4-import-into-unity.html",
    "title": "Realistic Looking Plastics - Import Into Unity | VPE Documentation",
    "keywords": "Import Into Unity Step 1: Import the FBX Open your scene in Unity and use the Project window to navigate to where you've exported your FBX. Note We recommend storing models at Assets/<Table Name>/Models , and texture at Assets/<Table Name>/Textures . If you haven't already, copy Plastics-01.png as Plastics.png and Plastics.fbx into the corresponding folders. Drag Plastics.fbx under the Playfield GameObject. Scale and rotate them until they have the approximate size. We recommend unpacking the prefab. Unpacking will still reference the meshes of your FBX, but not the position within the FBX. That way you're more flexible in positioning the plastics, and should you move them in Blender later you won't need to re-position them in Unity. In order to do that, right-click on the Plastics GameObject and select Prefab -> Unpack . Step 2: Setup Assets First, let's configure how the texture is imported. In the Project window, navigate to Assets/<Table Name>/Textures where you saved Plastics.png , and select it. In the Inspector window, check the option Alpha Is Transparent . Depending on how large you've exported it, you might need to update Max Size as well, in our case we'll use 4096 × 4096. When you're done, hit Apply at the bottom. Next, we'll create a material of our bottom surface. In the Project window, navigate to Packages/Visual Pinball Engine (HDRP)/Assets/Art/Materials/Default/Plastic , select Plastics Decal , hit Ctrl + C . Navigate to your project's Assets/<Table Name>/Materials folder, and press Ctrl + V . Select the copied Plastics Decal . In the inspector, under Surface Inputs , click on the little circle next to Base Map , and type \"Plastics\" in the search box. Select the imported texture you've created and close the picker dialog. Step 3: Assign the Materials Now we have our materials ready, let's assign them to our plastics. Select all plastics GameObjects. In the inspector, under Mesh Renderer -> Materials , you should see three empty elements. These are our material slots. Drag the Plastics Decal material you've just updated into the last slot (Element 2). Then, in the Project window, navigate to where you were before, to Packages/Visual Pinball Engine (HDRP)/Assets/Art/Materials/Default/Plastic . Drag Plastics Edges to Element 0 and Plastic Top to Element 1 . Note For some reason, material slots might be different depending on the object, so you'll need to verify if all the plastics look correct, and shuffle the material slots if necessary (you can just re-order them under Materials ). If all went well, it should look like that! Transparent Plastics If you had completely transparent plastics without any artwork, you'll notice that they are still textured: In order to fix that, replace the Plastics Decal material with the Plastics Top material, and it will look correct: Step 4: Alignment Use the Scene View to move each plastic to the right position. You'll also need to rotate them and probably resize them as well. Tip: Once you're happy with all positions, set height of the plastic of all objects to the same value by selecting them in the Hierarchy and putting a Z-value of Scale in the Transform panel of the Inspector. That's It! If you came across an error or have a better way of achieving this, don't hesitate to click on the Improve this Doc button on the top right side ( documentation )."
  },
  "creators-guide/tutorials/relatistic-plastics/index.html": {
    "href": "creators-guide/tutorials/relatistic-plastics/index.html",
    "title": "Create Realistic Looking Plastics | VPE Documentation",
    "keywords": "Create Realistic Looking Plastics This tutorial runs through a workflow that has been working well for us, from exporting the art and surfaces from a vector graphics program like Adobe Illustrator, through creating the mesh in Blender, to importing it into Unity setting up the correct materials. For mesh creation, we'll use vector outlines that are part of the plastics artwork. This allows us to precisely align the artwork to the future mesh. Overview The result of this workflow is a set of GameObjects in Unity with the typical plastic look. For that, our meshes consist of three pieces, each assigned to a material slot: The top surface, acting as the semi-transparent plastic. The side faces that include a simple bevel. This is where we add the refraction effect. The bottom surface, with the normals pointing up. This is where the texture is mapped to. Every plastic will have its own GameObject. However, only one texture is shared between all the plastics. The final result! Prerequisites While we provide some guidelines for the artwork, we won't go into detail how to produce it. So, we assume that you have your artwork ready. You should be familiar with a vector graphics software such as Adobe Illustrator. You should know your way around in Blender. Beginner level is fine, but you should be able to navigate in the viewport, know what UV-mapping is and know the basics about modifiers. Workflow Prepare Artwork Create mesh in Blender UV-map texture in Blender Import mesh into Unity Alternative Workflow with Houdini If you're familiar with Houdini, you might be interested in replacing Blender with Houdini. The problem with Blender is that it's a destructive workflow, i.e., if you have to change the outlines from which the mesh is generated from, you'll need to redo steps two and three. Houdini however is completely non-destructive, so here's a workflow that allows you to quickly regenerate meshes in case you need make changes when placing them on the playfield."
  },
  "creators-guide/vpe.html": {
    "href": "creators-guide/vpe.html",
    "title": "Features | VPE Documentation",
    "keywords": "Features Tutorial VPE Manual Game Items Pinball Mechanisms Scripting Physics Plugins About VPE About this Documentation Authors License and Copyright FAQ Glossary Contributing to VPE"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome | VPE Documentation",
    "keywords": "Welcome to the documentation of the Start here with the creator's guide . Be aware we're at the very beginning of writing documentation. You'll see weird content."
  },
  "plugins/index.html": {
    "href": "plugins/index.html",
    "title": "Plugins | VPE Documentation",
    "keywords": "Plugins VPE has a plug-in system that allows other software to integrate with it. Plugins are typically required on a per-table basis. VPE ships with a number of default plugins which are documented here. PinMAME PinMAME is an emulator written in C which supports most of the hardware found in pinball machines the mid 1970's until 2014. Mission Pinball Framework The Mission Pinball Framework is software written in Python that is used to drive real pinball machines. It integrates with VPE as a gamelogic engine."
  },
  "plugins/mpf/index.html": {
    "href": "plugins/mpf/index.html",
    "title": "Mission Pinball Framework | VPE Documentation",
    "keywords": "Mission Pinball Framework VPE connects to MPF using gRPC , which is a high-performance, low-latency RPC framework. It works by VPE launching MPF as a Python process. MPF will then spawn a gRPC server, to which VPE connects to. There are two situations when this is done: In edit mode to retrieve available switches, coils and lamps During runtime to drive the game VPE supports MPF's hardware rules , which are dynamic connections between coils and switches handled by the controller boards in order to reduce latency. The media controller is not yet supported."
  },
  "plugins/mpf/setup.html": {
    "href": "plugins/mpf/setup.html",
    "title": "MPF Setup | VPE Documentation",
    "keywords": "Setup Prerequisites Future plans include shipping MPF entirely with Unity, but currently, you need to have MPF installed on your machine. You can install MPF by: Installing Python 3.7 pip install --pre mpf mpf-mc You can upgrade MPF if you already have installed it by running: pip install mpf mpf-mc --pre --upgrade Note: On MacOS, you may have to substitue pip with pip3 . You will need at least MPF v0.55.0-dev.12. Unity Setup Mission Pinball Framework integration comes as an UPM package. In Unity, add it by choosing Window -> Package Manager -> Add package from git URL : Then, input org.visualpinball.engine.missionpinball and click Add or press Enter . This will download and add MPF to the project. Note You will need to have our scoped registry added in order for Unity to find the MPF package. How to do this is documented in the general setup section . So let's test it ."
  },
  "plugins/mpf/usage.html": {
    "href": "plugins/mpf/usage.html",
    "title": "MPF Usage | VPE Documentation",
    "keywords": "Usage MPF support is implemented as a Gamelogic Engine . It's a Unity Component , so all you have to do is add it to the root node of your table. You can do this by selecting the table in the hierarchy, then click Add Component in the inspector and select Visual Pinball -> Game Logic Engine -> Mission Pinball Framework . Retrieve Machine Description Since the gamelogic engine is the part of VPE that provides switch, coil, and lamp definitions so VPE can link them to the table during gameplay, you'll need to retrieve them from MPF. You can do this by clicking Get Machine Description in the MPF component's inspector. This will save it to the component. You will only need to do this once unless you update the MPF machine config. Note While VPE could read the MPF machine config itself, we let MPF handle it. That means we run MPF with the given machine config and then query its hardware. While this is a bit slower, it has the advantage of coherent behavior between edit time and runtime, and doesn't add an additional maintenance burden. Wire It Up Now that VPE knows which switches, coils, and lamps your machine expects, you'll need to connect them using the switch , coil , and lamp manager . You can watch the entire process in a quick video here:"
  },
  "plugins/pinmame/index.html": {
    "href": "plugins/pinmame/index.html",
    "title": "PinMAME | VPE Documentation",
    "keywords": "PinMAME VPE integrates with PinMAME using a .NET wrapper called pinmame-dotnet , which under the hood uses a cross-platform build called libpinmame ."
  },
  "plugins/pinmame/mechs.html": {
    "href": "plugins/pinmame/mechs.html",
    "title": "PinMAME Mech Handlers | VPE Documentation",
    "keywords": "PinMAME Mech Handlers A pinball table contains many mechanisms that interact with the ball. Classic examples are the flippers, kickers, or the trough. However, when we refer to PinMAME Mechs , we refer to very specific mechanisms involving a motor - usually toys of some sort. Mechs come in all forms and complexities. Some like the pole dancers in the Sopranos are for show only, while many others serve a very specifc purpose during gameplay. A few more examples are Rudy's eyes in Funhouse, the cannon in Terminator 2, the glove in Johnny Mnemonic which has full player control, or the spinning wheels in Whirlwind. To understand how PinMAME handles mechs, a bit of history is needed. Before there even was PinMAME (it was called WPCMAME at the time, because it would only emulate WPC games), the dev team needed some way to \"play\" the game so they could check the sounds and the animations of the ROM. So, what they did is they wrote a simulator that would close and open switches at the appropriate times to fool the game into thinking everything works as designed. For example, when T2's cannon is rotating and you push the fire button, it would literally calculate the position of the gun, and which drop target the ball would hit and enable the switch of that target after a short delay. Of course, PinMAME doesn't include a physical simulation that includes geometry and gravity and such, so the simulation of the ball trajectory was quite approximative. Then came along Visual Pinball, and \"physical\" simulation was not needed anymore. However, some calculations done by PinMAME's simulator were still of interest. Let's take again T2's cannon. The game starts the motor, which will then start rotating the cannon. At certain rotation angles, a physical switch tells the game how far the cannon has rotated. There is also an end position at which the movement changes direction, rotating the cannon back in the opposite direction. Just for knowing the rotation angle of the cannon there's a lot of math and timing involved. That's why PinMAME offers a way to provide the result of these calculations back to Visual Pinball with the GetMech() API. In the table script, you would tell PinMAME which mechs to simulate and regularly retrieve the result in order to just update the rendered elements on the playfield. Switches and coils involving the mech would also be handled by PinMAME. However, this worked only for a handful of fully simulated WPC games, and even for those, parameters needed to be tweaked, which was impossible with this approach. So, something more generic was needed. And this finally brings us back to our original topic: Custom mechs handlers , or PinMAME Mech Handlers as we call them. They work like the internal simulation but can be configured through an API. To sum it up, in Visual Pinball , there are three approaches today to deal with mechs: Use PinMAME's internal simulation - nearly never used. Configure a custom mech handler - occasionally used. Use timers and handle everything in the table script - the most common approach. This page is about approach #2 and describes how you can configure and use PinMAME mech handlers in VPE. Note Some toys like High Roller Casino's slot machine toy are too complex to be simulated with a PinMAME mech handler. Understanding how the toy works is key here. We will try our best to provide components that are able to cover most of your mech needs. Setup PinMAME can simulate up to five custom mechs. You create one by adding the PinMAME Mech component onto a game object. Note If you come from Visual Pinball, this component has the same function as the cvpmMech class in core.vbs . Type This defines how the mech is controlled. There are four options: One Solenoid - The motor turns in one direction only, and the solenoid turns it on and off. Example: Sopranos pole dancers. One Directional Solenoid - Two solenoids, one for enabling the motor, one for setting the direction. Example: The cannon in T2. Two Directional Solenoids - The first solenoid controls clockwise movement and the second solenoid controls counter-clockwise movement. Example: The soccer ball in World Cup Soccer '94. Two Stepper Solenoids - Two solenoids that control a stepper motor. Example: Drag strip cars in Corvette. Four Stepper Solenoids - Four solenoids that control a stepper motor. Only the first solenoid is defined and PinMAME assumes that the three remaining solenoids are the following coil numbers. Repeat How the mech behaves when the end of the range of motion is reached. There are three options: Circle - Loops, i.e., starts the motion again from the beginning. Reverse - Reverses the direction, i.e., moves back to the beginning. Stop at End - Automatically stops when the end has reached. Length The length is the amount of time, in milliseconds, that the specified solenoids must be enabled for, to move a single step in the progression from the start to end position. It indirectly defines the speed. Steps This is the total number of steps from the start to the end position. Every time a new step is reached the mech is updated with a new value. Movement, Speed and Output Value Check Linear Movement (default) if you need to simulate a linear movement, as opposed to non-linear movement. Check Fast Updates if the calculations should be updated at 240Hz, as opposed to 60Hz (default). Check Result by Length if you want the result to be based on the length, as opposed to the number of steps (default). Acceleration and Retardation By default set to 0, acceleration defines the amount of time in milliseconds required to reach full speed, while retardation defines the time required to come to a stop, in relation to acceleration . For example, setting of Acceleration = 50 and Retardation = 0.2 corresponds to 50ms to reach full speed and comes to a stop 10ms after the solenoid turns off. Both values are 0 per default. Switches A PinMAME mech can handle up to 20 switches. Depending on the type, they have different behavior and different parameters: A switch set to Enable Between will be closed by PinMAME when the mech position is between a range of defined steps. A switch set to Always Pulse is constantly closed and opened when the motor is running. You configure the frequency and the duration it stays closed. A switch set to Pulse Between is pulsed for one step with a configurable frequency during a range of steps. Note If you come from Visual Pinball, Enable Between corresponds to AddSw , Always Pulse to AddPulseSw , and Pulse Between to AddPulseSwNew . Switch and Coil Assignments As described above, a mech comes with at least one solenoid and up to 20 switches. In order to tell PinMAME which solenoid to listen to and which switches to trigger, we use the Coil Manager and the Switch Manager . Here is an example configuration that drives the gun in T2: Here, the PinMAME Mech Handler sits on a game object named \"Cannon\". Note The reason VPE uses the managers to assign the right number (as opposed to letting you specify it directly in the component) is that everything switch or coil related is at one place, and that the same principle can be re-used for other GLEs or components. Runtime During gameplay, PinMAME executes callback for each mech with the current step position."
  }
}